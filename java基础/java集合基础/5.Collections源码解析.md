[TOC]
# ä¸€ã€Collectionsæ¥å£æ˜¯åšä»€ä¹ˆçš„ï¼Ÿ
ç”¨å®˜ç½‘æ–‡æ¡£çš„ä»‹ç»ï¼š
> The polymorphic algorithms described here are pieces of reusable functionality provided by theÂ JavaÂ platform. All of them come from the Collections class, and all take the form of static methods whose first argument is the collection on which the operation is to be performed. The great majority of the algorithms provided by the Java platform operate on List instances, but a few of them operate on arbitrary Collection instances.ï¼ˆè¿™é‡Œæè¿°çš„å¤šæ€ç®—æ³•æ˜¯Javaå¹³å°æä¾›çš„å¯é‡ç”¨åŠŸèƒ½çš„ä¸€éƒ¨åˆ†ã€‚å®ƒä»¬éƒ½æ¥è‡ªCollectionsç±»ï¼Œéƒ½é‡‡ç”¨é™æ€æ–¹æ³•çš„å½¢å¼ï¼Œå…¶ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯è¦æ‰§è¡Œæ“ä½œçš„é›†åˆã€‚Javaå¹³å°æä¾›çš„ç»å¤§å¤šæ•°ç®—æ³•éƒ½å¯¹åˆ—è¡¨å®ä¾‹è¿›è¡Œæ“ä½œï¼Œä½†ä¹Ÿæœ‰å°‘æ•°ç®—æ³•å¯¹ä»»æ„é›†åˆå®ä¾‹è¿›è¡Œæ“ä½œã€‚ï¼‰

ä»ä»‹ç»æ¥çœ‹ï¼Œè¿™å…¶å®æ˜¯ä¸€ä¸ªå·¥å…·ç±»ï¼Œå®ç°äº†ä¸€äº›å¸¸ç”¨çš„ç®—æ³•ï¼Œæ–¹ä¾¿æˆ‘ä»¬æ“ä½œé›†åˆï¼Œå¦‚æœæ²¡æœ‰è¿™ä¸ªç±»ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå°±æ˜¯è‡ªå·±å†™æ¯”è¾ƒéº»çƒ¦ğŸ˜‚ã€‚ä½†æ˜¯å‘¢ï¼Œæœ‰äº†è¿™ä¸ªç±»ï¼Œå¹³æ—¶å†™ä»£ç æˆ‘ä»¬å¯ä»¥ç›´æ¥è°ƒç”¨ï¼ˆå‰ææ˜¯äº†è§£é‡Œé¢æ€ä¹ˆå®ç°çš„ï¼Œå®ç°äº†ä»€ä¹ˆåŠŸèƒ½ï¼‰ï¼Œæ¯•ç«Ÿä¸æ˜¯æ‰€æœ‰çš„è½®å­éƒ½è¦é‡å¤é€ ã€‚ä½†æ˜¯ï¼Œä¸æ˜¯æœ‰è½®å­äº†ï¼Œæˆ‘ä»¬å°±å¯ä»¥ä¸å»æ·±ç©¶é‡Œé¢åˆ°åº•æ˜¯å•¥ï¼Œé‡è¦çš„ä¸æ˜¯é€ è½®å­ï¼Œè€Œæ˜¯ï¼Œ**æˆ‘ä»¬å¿…é¡»æœ‰èƒ½å¤Ÿé€ è½®å­çš„èƒ½åŠ›**ã€‚

# äºŒã€Collectionsæºç ä¹‹å¤§ç±»æ–¹æ³•
## 1.æä¾›ä¸å¯å˜é›†åˆ
ä¸€èˆ¬æ˜¯é€šè¿‡ä¸€ä¸ªæ–¹æ³•ç›´æ¥è·å–ä¸å¯å˜çš„é›†åˆï¼Œé‡Œé¢åŒ…å«äº†ä¸å¯å˜çš„`Collection`ï¼Œ`Set`ï¼Œ`SortedSet`ï¼Œ`NavigableSet`ï¼Œ`List`ï¼Œ`SortedMap`ï¼Œ`NavigableMap`ã€‚
```java
    // è·å–ä¸å¯å˜çš„Collection
    public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c) {
        return new UnmodifiableCollection<>(c);
    }
    // è·å–ä¸å¯å˜çš„Set
    public static <T> Set<T> unmodifiableSet(Set<? extends T> s) {
        return new UnmodifiableSet<>(s);
    }
    // è·å–ä¸å¯å˜çš„SortedSet
   public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> s) {
        return new UnmodifiableSortedSet<>(s);
    }
    // è·å–ä¸å¯å˜çš„NavigableSet
    public static <T> NavigableSet<T> unmodifiableNavigableSet(NavigableSet<T> s) {
        return new UnmodifiableNavigableSet<>(s);
    }
    // è·å–ä¸å¯å˜çš„List
    public static <T> List<T> unmodifiableList(List<? extends T> list) {
        return (list instanceof RandomAccess ?
                new UnmodifiableRandomAccessList<>(list) :
                new UnmodifiableList<>(list));
    }
    // è·å–ä¸å¯å˜çš„SortedMap
    public static <K,V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K, ? extends V> m) {
        return new UnmodifiableSortedMap<>(m);
    }
    // è·å–ä¸å¯å˜çš„NavigableMap
    public static <K,V> NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap<K, ? extends V> m) {
        return new UnmodifiableNavigableMap<>(m);
    }
```
ä½†æ˜¯è¿™äº›ä¸å¯å˜çš„é›†åˆåˆ°åº•æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ€ä¹ˆä½¿ç”¨å‘¢ï¼Ÿ
æˆ‘ä»¬æ¥çœ‹ä¸€ä¸ªæœ€æ™®éçš„`UnmodifiableCollection`ç±»çš„æºç ï¼š
```java
    // å®ç°äº†Collectionå’Œåºåˆ—åŒ–æ¥å£
   static class UnmodifiableCollection<E> implements Collection<E>, Serializable {
        // å®šä¹‰åºåˆ—åŒ–çš„uid
        private static final long serialVersionUID = 1820017752578914078L;
        // å®šä¹‰æ•°æ®
        final Collection<? extends E> c;

        UnmodifiableCollection(Collection<? extends E> c) {
            if (c==null)
                throw new NullPointerException();
            this.c = c;
        }
        // è·å–å¤§å°
        public int size()                   {return c.size();}
        // æ˜¯å¦ä¸ºç©º
        public boolean isEmpty()            {return c.isEmpty();}
        // æ˜¯å¦åŒ…å«
        public boolean contains(Object o)   {return c.contains(o);}
        // è½¬æˆæ•°ç»„
        public Object[] toArray()           {return c.toArray();}
        // è½¬æˆç‰¹å®šç±»å‹æ•°ç»„
        public <T> T[] toArray(T[] a)       {return c.toArray(a);}
        // toStringæ–¹æ³•
        public String toString()            {return c.toString();}
        // è·å–è¿­ä»£å™¨
        public Iterator<E> iterator() {
            // ç”¨å†…éƒ¨ç±»æ–¹å¼å®ç°
            return new Iterator<E>() {
                // è¿­ä»£å™¨å…¶å®æ˜¯cçš„è¿­ä»£å™¨
                private final Iterator<? extends E> i = c.iterator();
                // æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 
                public boolean hasNext() {return i.hasNext();}
                // è·å–ä¸‹ä¸€ä¸ª
                public E next()          {return i.next();}
                // ç§»é™¤å…ƒç´ 
                public void remove() {
                    throw new UnsupportedOperationException();
                }
                // éå†å‰©ä¸‹çš„å…ƒç´ 
                @Override
                public void forEachRemaining(Consumer<? super E> action) {
                    // Use backing collection version
                    i.forEachRemaining(action);
                }
            };
        }
        // å¢åŠ æ“ä½œæŠ›å¼‚å¸¸
        public boolean add(E e) {
            throw new UnsupportedOperationException();
        }
        //åˆ é™¤æ“ä½œæŠ›å¼‚å¸¸
        public boolean remove(Object o) {
            throw new UnsupportedOperationException();
        }
        // æ˜¯å¦åŒ…å«æ‰€æœ‰
        public boolean containsAll(Collection<?> coll) {
            return c.containsAll(coll);
        }
        // æ‰¹é‡æ·»åŠ æ“ä½œæŠ›å¼‚å¸¸
        public boolean addAll(Collection<? extends E> coll) {
            throw new UnsupportedOperationException();
        }
        // æ‰¹é‡åˆ é™¤æŠ›å¼‚å¸¸
        public boolean removeAll(Collection<?> coll) {
            throw new UnsupportedOperationException();
        }
        // å–äº¤é›†æŠ›å¼‚å¸¸
        public boolean retainAll(Collection<?> coll) {
            throw new UnsupportedOperationException();
        }
        // æ¸…ç©ºæ•°æ®æŠ›å¼‚å¸¸
        public void clear() {
            throw new UnsupportedOperationException();
        }

        // Override default methods in Collection
        @Override
        //éå†å…ƒç´ 
        public void forEach(Consumer<? super E> action) {
            c.forEach(action);
        }
        // æŒ‰ç…§æ¡ä»¶ç§»é™¤å…ƒç´ æŠ›å¼‚å¸¸
        @Override
        public boolean removeIf(Predicate<? super E> filter) {
            throw new UnsupportedOperationException();
        }
        // è·å–å¯åˆ†å‰²è¿­ä»£å™¨
        @SuppressWarnings("unchecked")
        @Override
        public Spliterator<E> spliterator() {
            return (Spliterator<E>)c.spliterator();
        }
        // è·å–æ•°æ®æµ
        @SuppressWarnings("unchecked")
        @Override
        public Stream<E> stream() {
            return (Stream<E>)c.stream();
        }
        // è·å–å¹¶è¡Œæµ
        @SuppressWarnings("unchecked")
        @Override
        public Stream<E> parallelStream() {
            return (Stream<E>)c.parallelStream();
        }
    }
```
ä»ä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºå…¶å®æ‰€è°“ä¸å¯å˜çš„é›†åˆï¼Œå°±æ˜¯ç”¨ä¸€ä¸ªåŒ…è£…ç±»ï¼ŒæŒæœ‰å¯¹å®é™…çš„é›†åˆçš„å¼•ç”¨ï¼Œåªèƒ½æ‰§è¡ŒæŸ¥è¯¢æ“ä½œï¼Œå…¶ä»–æ“ä½œéƒ½ä¼šæŠ›å‡ºå¼‚å¸¸`UnsupportedOperationException`ã€‚æˆ‘ä»¬æ¥çœ‹å…¶ä»–çš„ï¼Œéšä¾¿æŒ‘ä¸€ä¸ª`UnmodifiableMap`:
```java

    // å®ç°mapæ¥å£å’Œåºåˆ—åŒ–æ¥å£
   private static class UnmodifiableMap<K,V> implements Map<K,V>, Serializable {
        // åºåˆ—å·
        private static final long serialVersionUID = -1034234728574286014L;
        // æŒæœ‰çš„å¼•ç”¨
        private final Map<? extends K, ? extends V> m;
        // åˆå§‹åŒ–å‡½æ•°
        UnmodifiableMap(Map<? extends K, ? extends V> m) {
            if (m==null)
                throw new NullPointerException();
            this.m = m;
        }
        // æŸ¥è¯¢å¤§å°
        public int size()                        {return m.size();}
        // æ˜¯å¦ä¸ºç©º
        public boolean isEmpty()                 {return m.isEmpty();}
        // æ˜¯å¦åŒ…å«é”®
        public boolean containsKey(Object key)   {return m.containsKey(key);}
        // æ˜¯å¦åŒ…å«å€¼
        public boolean containsValue(Object val) {return m.containsValue(val);}
        // é€šè¿‡å€¼è·å–
        public V get(Object key)                 {return m.get(key);}
        // æ·»åŠ ï¼ˆæŠ›å¼‚å¸¸ï¼‰
        public V put(K key, V value) {
            throw new UnsupportedOperationException();
        }
        // åˆ é™¤å…ƒç´ ï¼ˆæŠ›å¼‚å¸¸ï¼‰
        public V remove(Object key) {
            throw new UnsupportedOperationException();
        }
        // æ‰¹é‡å¢åŠ ï¼ˆæŠ›å¼‚å¸¸ï¼‰
        public void putAll(Map<? extends K, ? extends V> m) {
            throw new UnsupportedOperationException();
        }
        // æ¸…ç©ºå…ƒç´ ï¼ˆæŠ›å¼‚å¸¸ï¼‰
        public void clear() {
            throw new UnsupportedOperationException();
        }
        // setçš„é›†åˆ
        private transient Set<K> keySet;
        // ebtryçš„é›†åˆ
        private transient Set<Map.Entry<K,V>> entrySet;
        // valueçš„é›†åˆ
        private transient Collection<V> values;
        // è·å–keyçš„é›†åˆ
        public Set<K> keySet() {
            if (keySet==null)
                // å¦‚æœä¸ä¸ºç©ºï¼ŒæŠŠkeysetä¹Ÿå˜æˆä¸€ä¸ªä¸å¯å˜çš„é›†åˆä¹‹åå†è¿”å›
                keySet = unmodifiableSet(m.keySet());
            return keySet;
        }

        public Set<Map.Entry<K,V>> entrySet() {
            if (entrySet==null)
                // å¦‚æœä¸ä¸ºç©ºï¼ŒæŠŠentrysetä¹Ÿå˜æˆä¸€ä¸ªä¸å¯å˜çš„é›†åˆä¹‹åå†è¿”å›
                entrySet = new UnmodifiableEntrySet<>(m.entrySet());
            return entrySet;
        }

        public Collection<V> values() {
            if (values==null)
                // // å¦‚æœä¸ä¸ºç©ºï¼ŒæŠŠvalueä¹Ÿå˜æˆä¸€ä¸ªä¸å¯å˜çš„é›†åˆä¹‹åå†è¿”å›
                values = unmodifiableCollection(m.values());
            return values;
        }
        // å¯¹è±¡çš„æ–¹æ³•åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œå¼•ç”¨ç›¸ç­‰ä¹Ÿæ˜¯åˆ¤æ–­ä¸ºç›¸ç­‰
        public boolean equals(Object o) {return o == this || m.equals(o);}
        // è®¡ç®—hash
        public int hashCode()           {return m.hashCode();}
        // toStringæ³•æ³•
        public String toString()        {return m.toString();}

        // é‡å†™æ–¹æ³•ï¼Œé€šè¿‡keyè·å–vauleï¼Œæ²¡æœ‰åˆ™è¿”å›é»˜è®¤å€¼
        @Override
        @SuppressWarnings("unchecked")
        public V getOrDefault(Object k, V defaultValue) {
            // Safe cast as we don't change the value
            return ((Map<K, V>)m).getOrDefault(k, defaultValue);
        }

        // éå†æ‰§è¡Œactionï¼ˆåŠ¨ä½œå‚æ•°åŒ–ï¼‰
        @Override
        public void forEach(BiConsumer<? super K, ? super V> action) {
            m.forEach(action);
        }

        // æ›¿æ¢æ‰€æœ‰ï¼ŒæŠ›å¼‚å¸¸
        @Override
        public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function) {
            throw new UnsupportedOperationException();
        }
        // å¦‚æœä¸å­˜åœ¨åˆ™æ”¾è¿›å»ï¼ŒæŠ›å¼‚å¸¸
        @Override
        public V putIfAbsent(K key, V value) {
            throw new UnsupportedOperationException();
        }

        //åˆ é™¤æ“ä½œï¼ŒæŠ›å¼‚å¸¸
        @Override
        public boolean remove(Object key, Object value) {
            throw new UnsupportedOperationException();
        }
        //æ›¿æ¢æ“ä½œï¼ŒæŠ›å¼‚å¸¸
        @Override
        public boolean replace(K key, V oldValue, V newValue) {
            throw new UnsupportedOperationException();
        }
        // æ›¿æ¢æ“ä½œæŠ›å¼‚å¸¸
        @Override
        public V replace(K key, V value) {
            throw new UnsupportedOperationException();
        }
        // æŠ›å¼‚å¸¸
        @Override
        public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction) {
            throw new UnsupportedOperationException();
        }
        // æŠ›å¼‚å¸¸
        @Override
        public V computeIfPresent(K key,
                BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
            throw new UnsupportedOperationException();
        }
        // æŠ›å¼‚å¸¸
        @Override
        public V compute(K key,
                BiFunction<? super K, ? super V, ? extends V> remappingFunction) {
            throw new UnsupportedOperationException();
        }
        // æŠ›å¼‚å¸¸
        @Override
        public V merge(K key, V value,
                BiFunction<? super V, ? super V, ? extends V> remappingFunction) {
            throw new UnsupportedOperationException();
        }

        /**
         * We need this class in addition to UnmodifiableSet as
         * Map.Entries themselves permit modification of the backing Map
         * via their setValue operation.  This class is subtle: there are
         * many possible attacks that must be thwarted.
         *
         * @serial include
         */
         // å°†mapå†…éƒ¨çš„Entryä¹Ÿç”¨ä¸€ä¸ªä¸å¯å˜çš„ç±»å­˜èµ·æ¥ï¼ˆå®é™…ä¸Šä¹Ÿæ˜¯å¼•ç”¨ï¼‰
        static class UnmodifiableEntrySet<K,V>
            extends UnmodifiableSet<Map.Entry<K,V>> {
            private static final long serialVersionUID = 7854390611657943733L;

            @SuppressWarnings({"unchecked", "rawtypes"})
            UnmodifiableEntrySet(Set<? extends Map.Entry<? extends K, ? extends V>> s) {
                // Need to cast to raw in order to work around a limitation in the type system
                super((Set)s);
            }
            // å¤„ç†entryçš„å…ƒç´ 
            static <K, V> Consumer<Map.Entry<K, V>> entryConsumer(Consumer<? super Entry<K, V>> action) {
                return e -> action.accept(new UnmodifiableEntry<>(e));
            }
            // éå†
            public void forEach(Consumer<? super Entry<K, V>> action) {
                Objects.requireNonNull(action);
                c.forEach(entryConsumer(action));
            }
            // ä¸å¯å˜entrysetçš„å¯åˆ†å‰²è¿­ä»£å™¨ï¼ˆä¸‹é¢æ–¹æ³•å’ŒSpliteratorçš„å·®ä¸å¤šï¼Œæ²¡æœ‰ä»€ä¹ˆå¥½è¯´ï¼‰
            static final class UnmodifiableEntrySetSpliterator<K, V>
                    implements Spliterator<Entry<K,V>> {
                final Spliterator<Map.Entry<K, V>> s;

                UnmodifiableEntrySetSpliterator(Spliterator<Entry<K, V>> s) {
                    this.s = s;
                }

                @Override
                public boolean tryAdvance(Consumer<? super Entry<K, V>> action) {
                    Objects.requireNonNull(action);
                    return s.tryAdvance(entryConsumer(action));
                }

                @Override
                public void forEachRemaining(Consumer<? super Entry<K, V>> action) {
                    Objects.requireNonNull(action);
                    s.forEachRemaining(entryConsumer(action));
                }

                @Override
                public Spliterator<Entry<K, V>> trySplit() {
                    Spliterator<Entry<K, V>> split = s.trySplit();
                    return split == null
                           ? null
                           : new UnmodifiableEntrySetSpliterator<>(split);
                }

                @Override
                public long estimateSize() {
                    return s.estimateSize();
                }

                @Override
                public long getExactSizeIfKnown() {
                    return s.getExactSizeIfKnown();
                }

                @Override
                public int characteristics() {
                    return s.characteristics();
                }

                @Override
                public boolean hasCharacteristics(int characteristics) {
                    return s.hasCharacteristics(characteristics);
                }

                @Override
                public Comparator<? super Entry<K, V>> getComparator() {
                    return s.getComparator();
                }
            }

            @SuppressWarnings("unchecked")
            public Spliterator<Entry<K,V>> spliterator() {
                return new UnmodifiableEntrySetSpliterator<>(
                        (Spliterator<Map.Entry<K, V>>) c.spliterator());
            }

            @Override
            public Stream<Entry<K,V>> stream() {
                return StreamSupport.stream(spliterator(), false);
            }

            @Override
            public Stream<Entry<K,V>> parallelStream() {
                return StreamSupport.stream(spliterator(), true);
            }

            public Iterator<Map.Entry<K,V>> iterator() {
                return new Iterator<Map.Entry<K,V>>() {
                    private final Iterator<? extends Map.Entry<? extends K, ? extends V>> i = c.iterator();

                    public boolean hasNext() {
                        return i.hasNext();
                    }
                    public Map.Entry<K,V> next() {
                        return new UnmodifiableEntry<>(i.next());
                    }
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                };
            }

            @SuppressWarnings("unchecked")
            public Object[] toArray() {
                Object[] a = c.toArray();
                for (int i=0; i<a.length; i++)
                    a[i] = new UnmodifiableEntry<>((Map.Entry<? extends K, ? extends V>)a[i]);
                return a;
            }

            @SuppressWarnings("unchecked")
            public <T> T[] toArray(T[] a) {
                // We don't pass a to c.toArray, to avoid window of
                // vulnerability wherein an unscrupulous multithreaded client
                // could get his hands on raw (unwrapped) Entries from c.
                Object[] arr = c.toArray(a.length==0 ? a : Arrays.copyOf(a, 0));

                for (int i=0; i<arr.length; i++)
                    arr[i] = new UnmodifiableEntry<>((Map.Entry<? extends K, ? extends V>)arr[i]);

                if (arr.length > a.length)
                    return (T[])arr;

                System.arraycopy(arr, 0, a, 0, arr.length);
                if (a.length > arr.length)
                    a[arr.length] = null;
                return a;
            }

            /**
             * This method is overridden to protect the backing set against
             * an object with a nefarious equals function that senses
             * that the equality-candidate is Map.Entry and calls its
             * setValue method.
             */
            public boolean contains(Object o) {
                if (!(o instanceof Map.Entry))
                    return false;
                return c.contains(
                    new UnmodifiableEntry<>((Map.Entry<?,?>) o));
            }

            /**
             * The next two methods are overridden to protect against
             * an unscrupulous List whose contains(Object o) method senses
             * when o is a Map.Entry, and calls o.setValue.
             */
            public boolean containsAll(Collection<?> coll) {
                for (Object e : coll) {
                    if (!contains(e)) // Invokes safe contains() above
                        return false;
                }
                return true;
            }
            public boolean equals(Object o) {
                if (o == this)
                    return true;

                if (!(o instanceof Set))
                    return false;
                Set<?> s = (Set<?>) o;
                if (s.size() != c.size())
                    return false;
                return containsAll(s); // Invokes safe containsAll() above
            }

            /**
             * This "wrapper class" serves two purposes: it prevents
             * the client from modifying the backing Map, by short-circuiting
             * the setValue method, and it protects the backing Map against
             * an ill-behaved Map.Entry that attempts to modify another
             * Map Entry when asked to perform an equality check.
             */
            private static class UnmodifiableEntry<K,V> implements Map.Entry<K,V> {
                private Map.Entry<? extends K, ? extends V> e;

                UnmodifiableEntry(Map.Entry<? extends K, ? extends V> e)
                        {this.e = Objects.requireNonNull(e);}

                public K getKey()        {return e.getKey();}
                public V getValue()      {return e.getValue();}
                public V setValue(V value) {
                    throw new UnsupportedOperationException();
                }
                public int hashCode()    {return e.hashCode();}
                public boolean equals(Object o) {
                    if (this == o)
                        return true;
                    if (!(o instanceof Map.Entry))
                        return false;
                    Map.Entry<?,?> t = (Map.Entry<?,?>)o;
                    return eq(e.getKey(),   t.getKey()) &&
                           eq(e.getValue(), t.getValue());
                }
                public String toString() {return e.toString();}
            }
        }
    }
```
`UnmodifiableMap`ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œå°±æ˜¯é‡Œé¢åˆ†æˆäº†`entry<key,value>`,`key`,`value`ä¸‰ä¸ªç»´åº¦ï¼Œ`UnmodifiableEntrySet<K,V>`ç»§æ‰¿äº†`UnmodifiableEntry<K,V>`è€Œ`UnmodifiableEntry<K,V>`å®ç°äº†`Map.Entry<K,V>`ï¼Œäº‹å®ä¸Šä¹Ÿæ˜¯æŒæœ‰å¯¹é›†åˆçš„å¼•ç”¨ï¼ŒæŠŠä¿®æ”¹æ“ä½œå…¨éƒ¨ç¦æ‰ï¼Œä¸€æ—¦è°ƒç”¨å°±ä¼šæŠ›å‡ºå¼‚å¸¸ã€‚
ä¸Šé¢çš„ä¸å¯å˜é›†åˆæä¾›æ–¹æ³•ç›´æ¥è·å–ï¼Œå¦‚ä¸‹å›¾ï¼š
![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20200307164120.png)
## 2ã€æä¾›åŒæ­¥çš„é›†åˆ
çœ‹ä¸‹é¢çš„å›¾ç‰‡ï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™ä¸ªå·¥å…·ç±»å…¶å®æä¾›äº†å¾ˆå¤šåŒæ­¥çš„é›†åˆç±»ï¼Œä½†æ˜¯éƒ½æ˜¯åŸºäºSynchronizeæ¥å®ç°çš„ï¼Œå¼€é”€ç›¸å¯¹æ¯”è¾ƒå¤§ï¼Œæœ‰ç‚¹ç‚¹æš´åŠ›äº†ã€‚æºå¤´å°±æ˜¯`SynchronizedCollection`,å®ç°äº†`Collection`æ¥å£ã€‚
![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20200307162643.png)

æˆ‘ä»¬æ¥çœ‹æºç ,æ˜æ˜¾å¯ä»¥å‘ç°ï¼Œé‡Œé¢å¤„ç†é›†åˆçš„å¼•ç”¨å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªå¯¹è±¡ï¼Œ`mutex`ï¼Œè¿™å°±æ˜¯é”çš„å…³é”®äº†ï¼Œä¹Ÿå°±æ˜¯åŒæ­¥çš„å¯¹è±¡ï¼Œå¯ä»¥çœ‹åˆ°ä¸‹é¢å‡ ä¹æ‰€æœ‰çš„æ–¹æ³•éƒ½è¢«åŠ ä¸Šäº†`Synchronize`åŒæ­¥ï¼Œè¿™æ ·å­ç¡®å®ä¿æŒäº†çº¿ç¨‹å®‰å…¨ï¼Œä½†æ˜¯è¿™æ ·æœ‰ç‚¹å½±å“æ•ˆç‡ï¼Œå¦‚æœä¸é‚£ä¹ˆè€ƒè™‘æ•ˆç‡çš„è¯ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨è¿™ä¸ªã€‚
```java
    static class SynchronizedCollection<E> implements Collection<E>, Serializable {
        private static final long serialVersionUID = 3053995032091335093L;

        final Collection<E> c;  // Backing Collection
        final Object mutex;     // Object on which to synchronize

        SynchronizedCollection(Collection<E> c) {
            this.c = Objects.requireNonNull(c);
            mutex = this;
        }

        SynchronizedCollection(Collection<E> c, Object mutex) {
            this.c = Objects.requireNonNull(c);
            this.mutex = Objects.requireNonNull(mutex);
        }

        public int size() {
            synchronized (mutex) {return c.size();}
        }
        public boolean isEmpty() {
            synchronized (mutex) {return c.isEmpty();}
        }
        public boolean contains(Object o) {
            synchronized (mutex) {return c.contains(o);}
        }
        public Object[] toArray() {
            synchronized (mutex) {return c.toArray();}
        }
        public <T> T[] toArray(T[] a) {
            synchronized (mutex) {return c.toArray(a);}
        }

        public Iterator<E> iterator() {
            return c.iterator(); // Must be manually synched by user!
        }

        public boolean add(E e) {
            synchronized (mutex) {return c.add(e);}
        }
        public boolean remove(Object o) {
            synchronized (mutex) {return c.remove(o);}
        }

        public boolean containsAll(Collection<?> coll) {
            synchronized (mutex) {return c.containsAll(coll);}
        }
        public boolean addAll(Collection<? extends E> coll) {
            synchronized (mutex) {return c.addAll(coll);}
        }
        public boolean removeAll(Collection<?> coll) {
            synchronized (mutex) {return c.removeAll(coll);}
        }
        public boolean retainAll(Collection<?> coll) {
            synchronized (mutex) {return c.retainAll(coll);}
        }
        public void clear() {
            synchronized (mutex) {c.clear();}
        }
        public String toString() {
            synchronized (mutex) {return c.toString();}
        }
        // Override default methods in Collection
        @Override
        public void forEach(Consumer<? super E> consumer) {
            synchronized (mutex) {c.forEach(consumer);}
        }
        @Override
        public boolean removeIf(Predicate<? super E> filter) {
            synchronized (mutex) {return c.removeIf(filter);}
        }
        @Override
        public Spliterator<E> spliterator() {
            return c.spliterator(); // Must be manually synched by user!
        }
        @Override
        public Stream<E> stream() {
            return c.stream(); // Must be manually synched by user!
        }
        @Override
        public Stream<E> parallelStream() {
            return c.parallelStream(); // Must be manually synched by user!
        }
        private void writeObject(ObjectOutputStream s) throws IOException {
            synchronized (mutex) {s.defaultWriteObject();}
        }
    }
```
å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œè¿˜æœ‰å‡ ä¸ªæ–¹æ³•æ²¡æœ‰è¢«åŠ ä¸Šé”ï¼Œé‚£å°±æ˜¯æ‰€æœ‰è·å–æµå’Œè¿­ä»£å™¨çš„æ–¹æ³•éƒ½æ²¡æœ‰ï¼Œ`iterator()`,`spliterator`,`stream`,`parallelStream`,éƒ½æœ‰ä¸€å¥è¯æ³¨é‡Šï¼š**Must be manually synched by user!**,å°±æ˜¯å«æˆ‘ä»¬é•¿ç‚¹å¿ƒï¼Œå¦‚æœè¿­ä»£æˆ–è€…æµè®¡ç®—è®¾è®¡æ¶‰åŠåˆ°å¹¶å‘æ“ä½œï¼Œå¯èƒ½ä¼šæœ‰é—®é¢˜ï¼Œè¦ä½¿ç”¨è€…è‡ªå·±è€ƒè™‘ã€‚
è‡³æ­¤ï¼Œä»¥ä¸Šçš„åŒæ­¥å†…éƒ¨ç±»éƒ½æœ‰æ–¹æ³•ä¸ä¹‹å¯¹åº”ï¼Œä¹Ÿå°±æ˜¯ä¼ è¿›æ¥é›†åˆå°±è¡Œäº†ï¼Œä¼šç»™æˆ‘ä»¬è¿”å›ä¸€ä¸ªåŒæ­¥ç±»ï¼Œå¯ä»¥ç›´æ¥è·å–ï¼Œè¿™ä¹Ÿå¤ªæ–¹ä¾¿äº†å§ğŸ™ˆğŸ™ˆğŸ™ˆæ²¡å¬è¿‡é²è¿…è¯´ä¾¿å®œçš„ä¸œè¥¿å¾€å¾€æœ€è´µä¹ˆï¼ˆé²è¿…è¯´æ²¡æœ‰è¯´è¿‡ï¼‰,ä¹Ÿå°±æ˜¯æ•ˆç‡è‡ªå·±æƒè¡¡å¥½å°±è¡Œå•¦ğŸ‘€~
![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20200307163940.png)

## 3ã€ç±»å‹æ£€æŸ¥
è¿™ä¸ªåŒ…è£…ç±»è¿˜æä¾›äº†å¾ˆå¤šå…³äºç±»å‹æ£€æŸ¥çš„æ–¹æ³•ï¼š
![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20200307165037.png)
æˆ‘ä»¬æ¥çœ‹çœ‹æ˜¯å¹²å•¥çš„ï¼ŒæŒ‘ä¸€ä¸ª`checkedCollection()`çœ‹çœ‹ï¼š
```java
    public static <E> Collection<E> checkedCollection(Collection<E> c,
                                                      Class<E> type) {
        return new CheckedCollection<>(c, type);
    }
```
é¦–å…ˆè¿™ä¸ªæ–¹æ³•æ˜¯è¿”å›äº†ä¸€ä¸ª`CheckedCollection`ï¼Œæˆ‘çŒœè¿™ä¸ªç±»ä¹Ÿæ˜¯å°è£…äº†`Collection`,è·Ÿè¿›å»æºç çœ‹çœ‹ï¼š
```java
    static class CheckedCollection<E> implements Collection<E>, Serializable {
        private static final long serialVersionUID = 1578914078182001775L;

        final Collection<E> c;//æŒæœ‰å¼•ç”¨
        final Class<E> type;//æŒæœ‰ä¼ è¿›æ¥çš„ç±»å‹

        // æ£€æŸ¥ç±»å‹çš„å‡½æ•°
        @SuppressWarnings("unchecked")
        E typeCheck(Object o) {
            if (o != null && !type.isInstance(o))
                throw new ClassCastException(badElementMsg(o));
            return (E) o;
        }
        //ç±»å‹ä¸å¯¹åˆ™æ‰“å°é”™è¯¯ä¿¡æ¯
        private String badElementMsg(Object o) {
            return "Attempt to insert " + o.getClass() +
                " element into collection with element type " + type;
        }

        CheckedCollection(Collection<E> c, Class<E> type) {
            this.c = Objects.requireNonNull(c, "c");
            this.type = Objects.requireNonNull(type, "type");
        }

        public int size()                 { return c.size(); }
        public boolean isEmpty()          { return c.isEmpty(); }
        public boolean contains(Object o) { return c.contains(o); }
        public Object[] toArray()         { return c.toArray(); }
        public <T> T[] toArray(T[] a)     { return c.toArray(a); }
        public String toString()          { return c.toString(); }
        public boolean remove(Object o)   { return c.remove(o); }
        public void clear()               {        c.clear(); }

        public boolean containsAll(Collection<?> coll) {
            return c.containsAll(coll);
        }
        public boolean removeAll(Collection<?> coll) {
            return c.removeAll(coll);
        }
        public boolean retainAll(Collection<?> coll) {
            return c.retainAll(coll);
        }

        public Iterator<E> iterator() {
            // JDK-6363904 - unwrapped iterator could be typecast to
            // ListIterator with unsafe set()
            final Iterator<E> it = c.iterator();
            return new Iterator<E>() {
                public boolean hasNext() { return it.hasNext(); }
                public E next()          { return it.next(); }
                public void remove()     {        it.remove(); }};
        }
        // æ·»åŠ çš„æ—¶å€™æ‰§è¡Œç±»å‹æ£€æŸ¥
        public boolean add(E e)          { return c.add(typeCheck(e)); }

        private E[] zeroLengthElementArray; // Lazily initialized

        private E[] zeroLengthElementArray() {
            return zeroLengthElementArray != null ? zeroLengthElementArray :
                (zeroLengthElementArray = zeroLengthArray(type));
        }
        // copyçš„æ—¶å€™æ£€æŸ¥æ¯ä¸€ä¸ªå…ƒç´ 
        @SuppressWarnings("unchecked")
        Collection<E> checkedCopyOf(Collection<? extends E> coll) {
            Object[] a;
            try {
                E[] z = zeroLengthElementArray();
                a = coll.toArray(z);
                // Defend against coll violating the toArray contract
                if (a.getClass() != z.getClass())
                    a = Arrays.copyOf(a, a.length, z.getClass());
            } catch (ArrayStoreException ignore) {
                // To get better and consistent diagnostics,
                // we call typeCheck explicitly on each element.
                // We call clone() to defend against coll retaining a
                // reference to the returned array and storing a bad
                // element into it after it has been type checked.
                a = coll.toArray().clone();
                for (Object o : a)
                    typeCheck(o);
            }
            // A slight abuse of the type system, but safe here.
            return (Collection<E>) Arrays.asList(a);
        }
        // æ‰¹é‡æ·»åŠ çš„æ—¶å€™æ‰§è¡Œæ‹·è´æ£€æŸ¥æœºåˆ¶
        public boolean addAll(Collection<? extends E> coll) {
            // Doing things this way insulates us from concurrent changes
            // in the contents of coll and provides all-or-nothing
            // semantics (which we wouldn't get if we type-checked each
            // element as we added it)
            return c.addAll(checkedCopyOf(coll));
        }

        // Override default methods in Collection
        @Override
        public void forEach(Consumer<? super E> action) {c.forEach(action);}
        @Override
        public boolean removeIf(Predicate<? super E> filter) {
            return c.removeIf(filter);
        }
        @Override
        public Spliterator<E> spliterator() {return c.spliterator();}
        @Override
        public Stream<E> stream()           {return c.stream();}
        @Override
        public Stream<E> parallelStream()   {return c.parallelStream();}
    }
```
ä¸Šé¢çš„æºç å¯ä»¥çœ‹å‡ºï¼Œè¿™äº›å°è£…ç±»æ²¡æœ‰ä»€ä¹ˆç‰¹æ®Šçš„åœ°æ–¹ï¼Œåªæ˜¯åŒ…è£…äº†ä¸€å±‚ï¼Œæ‰§è¡Œæ·»åŠ çš„æ—¶å€™ï¼Œæ£€æŸ¥ç±»å‹ï¼Œå¦‚æœä¸ç¬¦åˆåˆ™æŠ›å‡ºå¼‚å¸¸ã€‚
## 4.æä¾›ç©ºé›†åˆæˆ–è€…è¿­ä»£å™¨
è¿™ä¸ªç±»è¿˜æä¾›äº†ä¸€äº›æ–¹æ³•å¯ä»¥è·å–åˆ°ç©ºé›†åˆï¼Œä¼šç”ŸæˆæŒ‡å®šç±»å‹çš„ç©º` List`,` Set`,` Map`ï¼Œè€Œä¸”æ˜¯ä¸å¯å˜çš„ï¼Œå¦‚è¿›è¡Œ `add() `æ“ä½œä¼šæŠ¥` java.lang.UnsupportedOperationException`ã€‚
![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20200307170356.png)
æˆ‘ä»¬æ¥çœ‹`EmptyIterator`çš„æºç ,é‡Œé¢æœ‰å¯ä»¥finalçš„å¯¹è±¡`EMPTY_ITERATOR`ï¼Œé‡Œé¢çš„`hashNext()`æ–¹æ³•ç›´æ¥è¿”å›falseï¼Œ`remove()`,`next()`æ–¹æ³•ç›´æ¥ä¸åˆæ³•ã€‚
```java
    private static class EmptyIterator<E> implements Iterator<E> {
        static final EmptyIterator<Object> EMPTY_ITERATOR
            = new EmptyIterator<>();

        public boolean hasNext() { return false; }
        public E next() { throw new NoSuchElementException(); }
        public void remove() { throw new IllegalStateException(); }
        @Override
        public void forEachRemaining(Consumer<? super E> action) {
            Objects.requireNonNull(action);
        }
    }
```
ä¸ºå•¥è¦åšè¿™æ ·çš„é›†åˆå‘¢ï¼Ÿçœ‹äº†ä¸€ä¸‹å…¶ä»–çš„ç©ºé›†åˆï¼Œéƒ½æ˜¯ç©ºçš„ã€‚ğŸ¶æˆ‘æƒ³äº†å¾ˆä¹…ğŸ¤”ğŸ¤”

æˆ‘ä»¬å†™æµ‹è¯•ç”¨ä¾‹çš„æ—¶å€™å¯èƒ½éœ€è¦ä¸€ä¸ªç©ºçš„é›†åˆï¼Œæœ‰å¯èƒ½ç”¨åˆ°ï¼Œè¿˜æœ‰å°±æ˜¯å®ƒæ˜¯ç©ºé›†åˆï¼Œä½†æ˜¯å®ƒä¸ä¸ºnullï¼Œå¦‚æœéå†nullå°±ä¼šæŠ›ç©ºæŒ‡é’ˆï¼Œè¿™æ ·çš„è¯è¿˜æ˜¯ç”¨ä¸€ä¸ªç©ºé›†åˆå¥½äº†ã€‚è¿˜æ˜¯è›®æœ‰é“ç†çš„ï¼Œè€Œä¸”å½“æœ‰è¿™æ ·çš„éœ€æ±‚çš„æ—¶å€™ï¼Œä½¿ç”¨è¿™æ ·åˆå§‹åŒ–å¤§å°ä¸º0çš„é›†åˆçœç©ºé—´å•Šï¼Œè¿˜æ˜¯è›®æ–¹ä¾¿çš„ğŸ’¯

ç„¶åå°±æ˜¯`Set`ï¼Œ`List`ï¼Œ`Map`éƒ½æœ‰å¯¹åº”çš„å¯¹è±¡å¯ä»¥ç›´æ¥`Collections.EMPTY_SET`å³å¯ã€‚
![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20200307175208.png)

## 5.æä¾›singletonçš„é›†åˆæˆ–è€…è¿­ä»£å™¨
ä»ä¸‹é¢çš„å›¾ç‰‡å•Šï¼Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°è¿™ä¸ªç±»è¿˜æä¾›äº†è·å–singletonçš„List,Set,Map,è¿˜æœ‰Iterator,Spliteratorã€‚
![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/20200307175419.png)

è¿™äº›æ˜¯å•¥ï¼Œæœ‰å•¥ç”¨ï¼ŸğŸ¤”ğŸ¤”

å…ˆçœ‹çœ‹`singletonIterator`æºç ï¼š
```java
        return new Iterator<E>() {
            private boolean hasNext = true;
            public boolean hasNext() {
                return hasNext;
            }
            // hashNextåªèƒ½ä½¿ç”¨ä¸€æ¬¡å°±ç½®ä¸ºfalseï¼Œç¬¬äºŒæ¬¡nextæ–¹æ³•è°ƒç”¨ä¼šæŠ›å¼‚å¸¸
            public E next() {
                if (hasNext) {
                    hasNext = false;
                    return e;
                }
                throw new NoSuchElementException();
            }
            // ä¸å¯ç§»é™¤
            public void remove() {
                throw new UnsupportedOperationException();
            }
            //åªèƒ½éå†ä¸€ä¸ªå…ƒç´ 
            @Override
            public void forEachRemaining(Consumer<? super E> action) {
                Objects.requireNonNull(action);
                if (hasNext) {
                    action.accept(e);
                    hasNext = false;
                }
            }
        };
    }
```
SingletonListçš„æºç ï¼š
```java
    private static class SingletonList<E>
        extends AbstractList<E>
        implements RandomAccess, Serializable {

        private static final long serialVersionUID = 3093736618740652951L;

        private final E element;

        SingletonList(E obj)                {element = obj;}
        // è·å–è¿­ä»£å™¨ï¼Œåªèƒ½éå†ä¸€æ¬¡çš„è¿­ä»£å™¨
        public Iterator<E> iterator() {
            return singletonIterator(element);
        }

        public int size()                   {return 1;}

        public boolean contains(Object obj) {return eq(obj, element);}
        //åªå…è®¸å–ä¸€ä¸ªå…ƒç´ 
        public E get(int index) {
            if (index != 0)
              throw new IndexOutOfBoundsException("Index: "+index+", Size: 1");
            return element;
        }

        // Override default methods for Collection
        @Override
        public void forEach(Consumer<? super E> action) {
            action.accept(element);
        }
        @Override
        public boolean removeIf(Predicate<? super E> filter) {
            throw new UnsupportedOperationException();
        }
        @Override
        public void replaceAll(UnaryOperator<E> operator) {
            throw new UnsupportedOperationException();
        }
        @Override
        public void sort(Comparator<? super E> c) {
        }
        @Override
        public Spliterator<E> spliterator() {
            return singletonSpliterator(element);
        }
    }
```
å¦‚æœæˆ‘ä»¬åªæœ‰ä¸€ä¸ªå…ƒç´ å¹¶ä¸”æ°¸è¿œåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥è€ƒè™‘ä½¿ç”¨è¿™äº›ç±»ï¼Œè¿­ä»£å™¨å› ä¸ºè¿™äº›ç±»éƒ½å¯ä»¥é€šè¿‡è¿­ä»£å™¨è¿›è¡Œéå†ï¼Œæ‰€ä»¥è¿­ä»£å™¨ä¹Ÿé™åˆ¶äº†åªèƒ½éå†ä¸€ä¸ªå…ƒç´ ã€‚åœ¨åˆ›å»ºçš„æ—¶å€™ï¼Œå°±å°†å”¯ä¸€çš„å…ƒç´ ä¼ è¿›å»ï¼Œä¸å…è®¸æ”¹å˜ï¼Œä¹Ÿä¸å…è®¸åˆ é™¤ã€‚



# ä¸‰ã€ä»æºç çœ‹å…¶ä»–å¸¸ç”¨æ–¹æ³•

## 1. Sortï¼ˆæ’åºï¼‰
`public static <T extends Comparable<? super T>> void sort(List<T> list)`ï¼Œå…ƒç´ éœ€è¦å®ç°`Comparable`æ¥å£ï¼ŒæŒ‰ç…§æ¯”è¾ƒå™¨è¿›è¡Œæ’åºã€‚å†…éƒ¨è°ƒç”¨çš„æ˜¯Listçš„sort()æ–¹æ³•,å…ˆè½¬æˆæ•°ç»„ï¼Œå†å¯¹æ•°ç»„è¿›è¡Œæ’åºï¼Œæ’å¥½åºä¹‹åå†setä¿®æ”¹å€¼ã€‚
ä¸€å…±æœ‰ä¸¤ç§æ’åºæ–¹æ³•ï¼Œç¬¬ä¸€ç§ï¼š
```java

    public static <T extends Comparable<? super T>> void sort(List<T> list) {
        list.sort(null);
    }
```
ç¬¬äºŒç§ï¼š
```java

  public static <T> void sort(List<T> list, Comparator<? super T> c) {
        list.sort(c);
    }
```
ä¸¤ç§çœ‹èµ·æ¥çš„åŒºåˆ«åœ¨äºæœ‰æ²¡æœ‰æ¯”è¾ƒå™¨`Comparator`ï¼Œå†…éƒ¨éƒ½æ˜¯è°ƒç”¨äº†`List`çš„`sort()`æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•çš„æºç å¦‚ä¸‹ï¼Œå†…éƒ¨å…¶å®æ˜¯è°ƒç”¨äº†æ•°ç»„çš„æ’åºæ–¹æ³•ã€‚
```java
    default void sort(Comparator<? super E> c) {
        Object[] a = this.toArray();
        Arrays.sort(a, (Comparator) c);
        ListIterator<E> i = this.listIterator();
        for (Object e : a) {
            i.next();
            i.set((E) e);
        }
    }
````
ä½¿ç”¨æ–¹å¼ï¼Œå¦‚æœæ²¡æœ‰ä¼ å…¥Comparatorï¼Œé‚£ä¹ˆæ‰€æ’åºçš„ç±»éœ€è¦ç»§æ‰¿Comparableæ¥å£å¹¶é‡å†™compareToæ–¹æ³•ï¼Œæ³¨æ„ï¼šStringï¼ŒIntegerè¿™äº›ç±»å·²ç»å®ç°äº†Comparableæ¥å£ï¼Œæ‰€ä»¥ä¸éœ€è¦ä¼ å…¥æ¯”è¾ƒå™¨ä¹Ÿæ˜¯å¯ä»¥é»˜è®¤æ’åºçš„ã€‚

## 2. binarySearchï¼ˆäºŒåˆ†æœç´¢ï¼‰
äºŒåˆ†æœç´¢åŒæ ·æœ‰ä¸¤ä¸ªï¼š
```java
    int binarySearch(List<? extends Comparable<? super T>> list, T key) {
        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
            return Collections.indexedBinarySearch(list, key);
        else
            return Collections.iteratorBinarySearch(list, key);
    }
    
     public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c) {
        if (c==null)
            return binarySearch((List<? extends Comparable<? super T>>) list, key);

        if (list instanceof RandomAccess || list.size()<BINARYSEARCH_THRESHOLD)
            //å¯ä»¥å¿«é€ŸæŸ¥æ‰¾çš„ï¼Œç›´æ¥ç”¨ç´¢å¼•äºŒåˆ†
            return Collections.indexedBinarySearch(list, key, c);
        else
            //è¿­ä»£å™¨äºŒåˆ†
            return Collections.iteratorBinarySearch(list, key, c);
    }   
```
ä¸€ä¸ªéœ€è¦Listé‡Œé¢çš„å¯¹è±¡ç»§æ‰¿`Comparable`ï¼Œå®ç°é‡Œé¢çš„æ–¹æ³•ï¼Œå¦ä¸€ä¸ªåˆ™æ˜¯ä¸éœ€è¦ï¼Œä½†æ˜¯éœ€è¦ä¼ å…¥`Comparator`ï¼Œè¿™å…¶å®éƒ½æ˜¯ä¸€ä¸ªæ„æ€ï¼Œä¹Ÿå°±æ˜¯ä½ å¾—å‘Šè¯‰æˆ‘æ€ä¹ˆæ¯”è¾ƒå•Šæ˜¯ä¸æ˜¯ğŸ˜¬ğŸ˜¬ğŸ˜¬
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°é‡Œé¢è¿˜æ˜¯æœ‰ä¸¤ä¸ªåˆ†æ”¯ï¼Œä¸€ä¸ªæ˜¯ä½¿ç”¨ç´¢å¼•äºŒåˆ†ï¼Œä¸€ä¸ªæ˜¯è¿­ä»£å™¨äºŒåˆ†ï¼Œè¿™æ˜¯å•¥ï¼Ÿè¿™ä¸å¾—ä¸è¯´`RandomAccess`,`ArrayList`å®ç°äº†ä¸€ä¸ªå«åš`Â RandomAccess`Â çš„æ¥å£ï¼Œè€Œ` LinkedList` æ˜¯æ²¡æœ‰çš„,è¿™ä¸ªæ¥å£çš„æ„æ€æ˜¯ä¸€ä¸ªæ ‡è¯†ï¼Œè°å®ç°äº†ï¼Œè°å°±ï¼ˆç‰›é€¼ï¼‰ï¼Œå¼€ç©ç¬‘çš„ï¼Œè°å®ç°äº†ï¼Œå°±è¯´æ˜è¿™ä¸ªæ¥å£æ˜¯æ”¯æŒå¿«é€Ÿéšæœºè®¿é—®çš„ï¼Œæ‰€è°“å¿«é€Ÿéšæœºè®¿é—®å°±æ˜¯åº•å±‚ä¸æ˜¯é“¾è¡¨ï¼Œè€Œæ˜¯æ•°ç»„ï¼Œæ•°ç»„æ˜¯å¯ä»¥ç›´æ¥é€šè¿‡ä¸‹æ ‡å°±èƒ½å¿«é€ŸæŸ¥æ‰¾çš„å˜›ï¼Œç‰›é€¼ç‰›é€¼~å†åº•å±‚çš„ç»†èŠ‚å°±åé¢å†ç ”ç©¶ç ”ç©¶äº†ã€‚

## 3. reverse(åè½¬)
è€æ ·å­ï¼Œçœ‹æºç :
```java
    public static void reverse(List<?> list) {
        int size = list.size();
        if (size < REVERSE_THRESHOLD || list instanceof RandomAccess) {
            for (int i=0, mid=size>>1, j=size-1; i<mid; i++, j--)
                swap(list, i, j);
        } else {
            // instead of using a raw type here, it's possible to capture
            // the wildcard but it will require a call to a supplementary
            // private method
            ListIterator fwd = list.listIterator();
            ListIterator rev = list.listIterator(size);
            for (int i=0, mid=list.size()>>1; i<mid; i++) {
                Object tmp = fwd.next();
                fwd.set(rev.previous());
                rev.set(tmp);
            }
        }
    }
```
`REVERSE_THRESHOLD`å«åè½¬é˜ˆå€¼ï¼Œçœ‹ä¸Šé¢çš„æºç å®è¯´listçš„å¤§å°è¿˜æœ‰æ˜¯å¦æ˜¯RandomAccessä¼šå¯¼è‡´ä½¿ç”¨ä¸¤ç§ä¸åŒçš„ç®—æ³•è¿›è¡Œåè½¬ï¼Œä¸€ç§æ˜¯åŸºäºæ•°ç»„ç´¢å¼•ï¼Œä¸€ç§æ˜¯åŸºäºIteratorçš„æ€è·¯ã€‚

## 4. Shuffling(æ··æ’)
`public static void shuffle(List<?> list)`,å°†listçš„å…ƒç´ éšæœºæ‰“ä¹±ï¼Œè¿™ä¸ªæ–¹æ³•ä¹Ÿæœ‰ä¸¤ç§å‚æ•°ï¼Œä¸€ç§æ˜¯åªéœ€è¦listï¼Œä¸€ç§è¿˜éœ€è¦éšæœºå€¼Randomï¼Œä½†æ˜¯åº•å±‚ä¸€æ ·ï¼Œæ²¡æœ‰éšæœºæ•°çš„ä¼šæ–¹æ³•å†…éƒ¨ç”Ÿæˆå†è¿›è¡Œè°ƒç”¨ã€‚
```java
    public static void shuffle(List<?> list, Random rnd) {
        int size = list.size();
        if (size < SHUFFLE_THRESHOLD || list instanceof RandomAccess) {
            for (int i=size; i>1; i--)
                swap(list, i-1, rnd.nextInt(i));
        } else {
            Object arr[] = list.toArray();

            // Shuffle array
            for (int i=size; i>1; i--)
                swap(arr, i-1, rnd.nextInt(i));
            ListIterator it = list.listIterator();
            for (int i=0; i<arr.length; i++) {
                it.next();
                it.set(arr[i]);
            }
        }
    }
```
é‡Œé¢åŒæ ·æ˜¯åˆ†æˆæ ¹æ®ç´¢å¼•æ··æ’å’Œè¿­ä»£å™¨æ··æ’ï¼Œè€å¥—è·¯äº†ï¼Œæ··æ’çš„å…³é”®å°±æ˜¯æ ¹æ®éšæœºæ•°ï¼Œå°†é¡ºåºæ‰“ä¹±ï¼Œè¯´æ˜¯æ‰“ä¹±ï¼Œå…¶å®å°±æ˜¯ä¸¤ä¸ªä¸¤ä¸ªéšæœºäº’æ¢å•¦ã€‚
## 5.  äº¤æ¢ï¼ˆswapï¼‰
`public static void swap(List<?> list, int i, int j) `äº¤æ¢ä¸¤ä¸ªç´¢å¼•çš„å…ƒç´ 
ä¸Šé¢çš„æ··æ’æ¥å£ï¼Œæ‰“ä¹±é¡ºåºè°ƒç”¨çš„å°±æ˜¯äº¤æ¢æ¥å£ï¼Œè¿™ä¸ªå°±æ˜¯setå’Œgetï¼Œç›´æ¥ä¸Šæºç ã€‚
```java
    public static void swap(List<?> list, int i, int j) {
        final List l = list;
        l.set(i, l.set(j, l.get(i)));
    }
```
## 6.  æ‹·è´ï¼ˆcopyï¼‰
`public static <T> void copy(List<? super T> dest, List<? extends T> src)`ï¼Œcopyå‡ºä¸€ä¸ªå†…å®¹ä¸€è‡´çš„`list`ã€‚
```java
    public static <T> void copy(List<? super T> dest, List<? extends T> src) {
        int srcSize = src.size();
        // å¤§å°å¾—æ»¡è¶³æ¡ä»¶
        if (srcSize > dest.size())
            throw new IndexOutOfBoundsException("Source does not fit in dest");

        if (srcSize < COPY_THRESHOLD ||
            (src instanceof RandomAccess && dest instanceof RandomAccess)) {
            //ç´¢å¼•copy
            for (int i=0; i<srcSize; i++)
                dest.set(i, src.get(i));
        } else {
            //è¿­ä»£å™¨copy
            ListIterator<? super T> di=dest.listIterator();
            ListIterator<? extends T> si=src.listIterator();
            for (int i=0; i<srcSize; i++) {
                di.next();
                di.set(si.next());
            }
        }
    }
```
è¿™é‡Œé¢ä¹Ÿæ˜¯åˆ†ä¸ºä¸¤ç§ï¼Œä¸€ç§æ˜¯è¿­ä»£å™¨copyï¼Œä¸€ç§æ˜¯ç´¢å¼•ï¼Œçœ‹æ¥æ˜¯æƒ¯ç”¨æ‰‹æ³•äº†å•Šï¼Œæ¡ä»¶éƒ½æ˜¯`src instanceof RandomAccess`æˆ–è€…è¶…è¿‡æŸä¸ªé˜ˆå€¼ã€‚
## 7.  è¿”å›æœ€å°çš„å…ƒç´ ï¼ˆminï¼‰
æ‰€è°“å¤§å°ï¼Œæ ¹æ®æŒ‡å®šçš„æ¯”è¾ƒå™¨å†³å®šï¼Œ`static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll)`
åŒæ ·åˆ†ä¸ºæœ‰æ¯”è¾ƒå™¨å’Œæ— æ¯”è¾ƒå™¨ï¼Œæœ‰çš„è¯ç›´æ¥ä½¿ç”¨ä¼ è¿›æ¥çš„å‚æ•°ï¼Œæ²¡æœ‰çš„è¯ï¼Œå°±ä¼šä½¿ç”¨å¯¹è±¡çš„ã€‚
```java
    public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll) {
        Iterator<? extends T> i = coll.iterator();
        T candidate = i.next();
        //æŒ¨ä¸ªéå†ä¸€éï¼Œæ‰¾å‡ºæœ€å°
        while (i.hasNext()) {
            T next = i.next();
            if (next.compareTo(candidate) < 0)
                candidate = next;
        }
        return candidate;
    }
```
## 8.  è¿”å›æœ€å¤§çš„å…ƒç´ ï¼ˆmaxï¼‰
`static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)`
è¿™ä¸ªå’Œæ‰¾æœ€å°ä¸€ä¸ªé“ç†ï¼Œå°±æ˜¯æ¯”è¾ƒçš„æ—¶å€™ç›¸åã€‚
```java
    public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll) {
        Iterator<? extends T> i = coll.iterator();
        T candidate = i.next();

        while (i.hasNext()) {
            T next = i.next();
            if (next.compareTo(candidate) > 0)
                candidate = next;
        }
        return candidate;
    }
```
## 9.  æ—‹è½¬ï¼ˆRotateï¼‰
å°†ä¸€ä¸ªListæ—‹è½¬ï¼Œå‡å¦‚æœ‰ä¸ªåºåˆ—åˆ—listæ˜¯[1,2,3,4]ï¼Œè°ƒç”¨æ–¹æ³•Collections.rotate(list, 1)åï¼Œå¾—åˆ°listå°±å˜æˆ[4,1,2,3]ï¼Œ`public static void rotate(List<?> list, int distance)`
ä¹Ÿæ˜¯åˆ†æˆä¸¤ç§ï¼Œä¸€ç§åŸºäºç´¢å¼•ä¸€ç§åŸºäºè¿­ä»£å™¨ï¼š
```java
    public static void rotate(List<?> list, int distance) {
        if (list instanceof RandomAccess || list.size() < ROTATE_THRESHOLD)
            rotate1(list, distance);
        else
            rotate2(list, distance);
    }
```
æˆ‘ä»¬æ¥çœ‹çœ‹åŸºäºç´¢å¼•çš„æ—‹è½¬,é¦–å…ˆæŠŠéæ³•æƒ…å†µå¤„ç†ï¼Œå†é€šè¿‡å–ä½™æ•°è®¡ç®—å‡ºæ—‹è½¬è·ç¦»ï¼Œç„¶åä¸¤å±‚å¾ªç¯è¿›è¡Œæ—‹è½¬ï¼Œè¯´å®è¯ï¼Œè¿™ä»£ç å†™å¾—å€¼å¾—æˆ‘å­¦ä¹ ã€‚ç‰›å•ŠğŸ®ğŸ®ğŸ®
```java
    private static <T> void rotate1(List<T> list, int distance) {
        int size = list.size();
        if (size == 0)
            return;
        distance = distance % size;
        if (distance < 0)
            distance += size;
        if (distance == 0)
            return;

        for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) {
            T displaced = list.get(cycleStart);
            int i = cycleStart;
            do {
                i += distance;
                if (i >= size)
                    i -= size;
                displaced = list.set(i, displaced);
                nMoved ++;
            } while (i != cycleStart);
        }
    }
```
## 10.  æ›¿æ¢æ‰€æœ‰å…ƒç´ ï¼ˆreplaceAllï¼‰
`public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal)`
è¿™ä¸ªæ²¡å•¥å¥½è¯´å•Šï¼Œå°±æ˜¯æ›¿æ¢å…ƒç´ ã€‚å†™ä»£ç çš„äººæ˜¯è§‰å¾—ä»£ç å¤ªçŸ­äº†ä¹ˆï¼Œæ ¹æ®ç´¢å¼•æ›¿æ¢å’Œæ ¹æ®è¿­ä»£å™¨çš„éƒ½å†™åˆ°ä¸€ä¸ªæ–¹æ³•ï¼Œè€é•¿äº†è¿™ğŸ™„ğŸ™„ğŸ™„
```java
    public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal) {
        boolean result = false;
        int size = list.size();
        if (size < REPLACEALL_THRESHOLD || list instanceof RandomAccess) {
            if (oldVal==null) {
                for (int i=0; i<size; i++) {
                    if (list.get(i)==null) {
                        list.set(i, newVal);
                        result = true;
                    }
                }
            } else {
                for (int i=0; i<size; i++) {
                    if (oldVal.equals(list.get(i))) {
                        list.set(i, newVal);
                        result = true;
                    }
                }
            }
        } else {
            ListIterator<T> itr=list.listIterator();
            if (oldVal==null) {
                for (int i=0; i<size; i++) {
                    if (itr.next()==null) {
                        itr.set(newVal);
                        result = true;
                    }
                }
            } else {
                for (int i=0; i<size; i++) {
                    if (oldVal.equals(itr.next())) {
                        itr.set(newVal);
                        result = true;
                    }
                }
            }
        }
        return result;
    }
```
## 11.å¡«å……æ‰€æœ‰çš„å…ƒç´ (fill)
```java
    public static <T> void fill(List<? super T> list, T obj) {
        int size = list.size();

        if (size < FILL_THRESHOLD || list instanceof RandomAccess) {
            for (int i=0; i<size; i++)
                list.set(i, obj);
        } else {
            ListIterator<? super T> itr = list.listIterator();
            for (int i=0; i<size; i++) {
                itr.next();
                itr.set(obj);
            }
        }
    }
```
è¿™ä¸ªæ¥å£ä¸»è¦æ˜¯å°†listä¸­çš„å…ƒç´ å…¨éƒ¨æ›¿æ¢æˆä¼ å…¥çš„objï¼Œåº•å±‚ä¹Ÿæ˜¯åˆ†æˆä¸¤ç§ï¼Œä¸€ä¸ªæ˜¯æŒ‰ç…§ç´¢å¼•æ¥éå†ï¼Œä¸€ç§æ˜¯æŒ‰ç…§è¿­ä»£å™¨æ¥éå†ã€‚

## 12.æŸ¥æ‰¾å­åºåˆ—çš„ç´¢å¼•ä½ç½®ï¼ˆindexOfSubListï¼‰
å‚æ•°æ˜¯ä¸¤ä¸ªlistï¼Œä¸€ä¸ªæ˜¯æºListï¼Œä¸€ä¸ªæ˜¯ç›®æ ‡list,ä½œç”¨ä¸»è¦æ˜¯æŸ¥æ‰¾åˆ°ç›®æ ‡liståœ¨æºlistä¸­çš„èµ·å§‹ä½ç½®ï¼Œéœ€è¦æ˜¯è¿ç»­çš„ï¼Œåº•å±‚ç”¨äº†ä¸¤å±‚å¾ªç¯ï¼ŒåŒæ ·åˆ†ä¸ºä¸¤ç§æƒ…å†µæ¥è®¨è®ºã€‚
```java
    public static int indexOfSubList(List<?> source, List<?> target) {
        int sourceSize = source.size();
        int targetSize = target.size();
        int maxCandidate = sourceSize - targetSize;

        if (sourceSize < INDEXOFSUBLIST_THRESHOLD ||
            (source instanceof RandomAccess&&target instanceof RandomAccess)) {
        nextCand:
            for (int candidate = 0; candidate <= maxCandidate; candidate++) {
                for (int i=0, j=candidate; i<targetSize; i++, j++)
                    if (!eq(target.get(i), source.get(j)))
                        continue nextCand;  // Element mismatch, try next cand
                return candidate;  // All elements of candidate matched target
            }
        } else {  // Iterator version of above algorithm
            ListIterator<?> si = source.listIterator();
        nextCand:
            for (int candidate = 0; candidate <= maxCandidate; candidate++) {
                ListIterator<?> ti = target.listIterator();
                for (int i=0; i<targetSize; i++) {
                    if (!eq(ti.next(), si.next())) {
                        // Back up source iterator to next candidate
                        for (int j=0; j<i; j++)
                            si.previous();
                        continue nextCand;
                    }
                }
                return candidate;
            }
        }
        return -1;  // No candidate matched the target
    }
```
## 13.æŸ¥æ‰¾å­åºåˆ—çš„ç´¢å¼•ä½ç½®ï¼ˆlastIndexOfSubListï¼‰
å’Œä¸Šé¢ä¸å¤ªä¸€æ ·çš„åœ°æ–¹æ˜¯ï¼Œè¿™ä¸ªæ˜¯ä»åé¢å¼€å§‹æŸ¥æ‰¾ï¼Œå…¶ä»–çš„å·®ä¸å¤šä¸€æ ·ï¼Œåªè¦æœ‰ä¸€ä¸ªåŒ¹é…ä¸æ»¡è¶³ï¼Œåˆ™éœ€è¦æ”¹å˜åŒ¹é…ä½ç½®ã€‚
```java
   public static int lastIndexOfSubList(List<?> source, List<?> target) {
        int sourceSize = source.size();
        int targetSize = target.size();
        int maxCandidate = sourceSize - targetSize;

        if (sourceSize < INDEXOFSUBLIST_THRESHOLD ||
            source instanceof RandomAccess) {   // Index access version
        nextCand:
            for (int candidate = maxCandidate; candidate >= 0; candidate--) {
                for (int i=0, j=candidate; i<targetSize; i++, j++)
                    if (!eq(target.get(i), source.get(j)))
                        continue nextCand;  // Element mismatch, try next cand
                return candidate;  // All elements of candidate matched target
            }
        } else {  // Iterator version of above algorithm
            if (maxCandidate < 0)
                return -1;
            ListIterator<?> si = source.listIterator(maxCandidate);
        nextCand:
            for (int candidate = maxCandidate; candidate >= 0; candidate--) {
                ListIterator<?> ti = target.listIterator();
                for (int i=0; i<targetSize; i++) {
                    if (!eq(ti.next(), si.next())) {
                        if (candidate != 0) {
                            // Back up source iterator to next candidate
                            for (int j=0; j<=i+1; j++)
                                si.previous();
                        }
                        continue nextCand;
                    }
                }
                return candidate;
            }
        }
        return -1;  // No candidate matched the target
    }
```
## 14.æ‹·è´å…ƒç´ ä¸€æ ·çš„listï¼ˆnCopiesï¼‰
è¿™ä¸ªæ–¹æ³•åŠŸèƒ½æ˜¯è¿”å›ä¸€ä¸ªå¤§å°ä¸ºnï¼Œå…ƒç´ å…¨æ˜¯oçš„listã€‚
```java
    public static <T> List<T> nCopies(int n, T o) {
        if (n < 0)
            throw new IllegalArgumentException("List length = " + n);
        return new CopiesList<>(n, o);
    }
```
é‡Œé¢ç”¨åˆ°äº†`CopiesList`ï¼Œè¿™ä¸ªä¸»è¦æ˜¯ç»§æ‰¿`AbstractList`,å°è£…äº†åªæœ‰ä¸€ç§å…ƒç´ çš„å¤§å°ä¸ºnçš„listã€‚

## 15.è·å–åè½¬çš„æ¯”è¾ƒå™¨(reverseOrder)
```java
    public static <T> Comparator<T> reverseOrder() {
        return (Comparator<T>) ReverseComparator.REVERSE_ORDER;
    }
```
åœ¨æ–¹æ³•è°ƒç”¨è¿”å›ä¸€ä¸ªæ¯”è¾ƒå™¨ï¼Œå®ç°Comparableæ¥å£çš„å¯¹è±¡çš„é›†åˆçš„è‡ªç„¶é¡ºåºç›¸åã€‚

## 16.è¿”å›é›†åˆçš„æšä¸¾ï¼ˆenumrationï¼‰
ä¸»è¦æ˜¯ç”¨æ¥è·å–ä¸€ä¸ªæšä¸¾æŒ‡å®šé›†åˆ
```java
    public static <T> Enumeration<T> enumeration(final Collection<T> c) {
        return new Enumeration<T>() {
            private final Iterator<T> i = c.iterator();

            public boolean hasMoreElements() {
                return i.hasNext();
            }

            public T nextElement() {
                return i.next();
            }
        };
    }
```
## 17.è¿”å›æšä¸¾é›†åˆçš„list(list)
æ­£å¥½å’Œä¸Šé¢çš„ç›¸åï¼Œè¿™ä¸ªæ˜¯æ ¹æ®æšä¸¾ç±»å‹é›†åˆè¿”å›ä¸€ä¸ªlistã€‚
```java
    public static <T> ArrayList<T> list(Enumeration<T> e) {
        ArrayList<T> l = new ArrayList<>();
        while (e.hasMoreElements())
            l.add(e.nextElement());
        return l;
    }
```
## 18.è¿”å›æŸä¸ªå…ƒç´ å‡ºç°çš„é¢‘ç‡ï¼ˆfrequencyï¼‰
ä¸»è¦æ˜¯é€šè¿‡equalsæ¯”è¾ƒï¼Œéå†ä¸€éï¼Œç›¸ç­‰åˆ™æ¬¡æ•°åŠ ä¸€ã€‚
```java
    public static int frequency(Collection<?> c, Object o) {
        int result = 0;
        if (o == null) {
            for (Object e : c)
                if (e == null)
                    result++;
        } else {
            for (Object e : c)
                if (o.equals(e))
                    result++;
        }
        return result;
    }
```
## 19.åˆ¤æ–­æ˜¯å¦æœ‰ç›¸åŒçš„å…ƒç´ ï¼ˆdisjointï¼‰
ä¸»è¦æ˜¯æ¯”è¾ƒä¸¤ä¸ªé›†åˆä¸­æ˜¯å¦æœ‰ç›¸åŒçš„å…ƒç´ ï¼Œå½“ä¸¤ä¸ªé›†åˆä¸­æ²¡æœ‰ç›¸åŒçš„å…ƒç´ çš„æ—¶å€™ è¿”å› true ï¼Œå½“æœ‰ç›¸åŒçš„å…ƒç´ çš„æ—¶å€™è¿”å› false.
```java
    public static boolean disjoint(Collection<?> c1, Collection<?> c2) {

        Collection<?> contains = c2;
        Collection<?> iterate = c1;

        if (c1 instanceof Set) {
            iterate = c2;
            contains = c1;
        } else if (!(c2 instanceof Set)) {
            int c1size = c1.size();
            int c2size = c2.size();
            if (c1size == 0 || c2size == 0) {

                return true;
            }
            if (c1size > c2size) {
                iterate = c2;
                contains = c1;
            }
        }
        for (Object e : iterate) {
            if (contains.contains(e)) {
                return false;
            }
        }

        return true;
    }
```
## 20.æ‰¹é‡æ·»åŠ ï¼ˆaddAllï¼‰
æ”¯æŒå¯å˜å‚æ•°ï¼Œå¯ä»¥å®ç°æ·»åŠ å¤šä¸ªå…ƒç´ ã€‚
```java
    public static <T> boolean addAll(Collection<? super T> c, T... elements) {
        boolean result = false;
        for (T element : elements)
            result |= c.add(element);
        return result;
    }
```
## 21.Mapè½¬æˆSet(newSetFromMap)
å°†Mapè½¬æˆä¸€ä¸ªSet(SetFromMap)ï¼Œè¿™ä¹Ÿæ˜¯ä¸€ä¸ªå°è£…çš„Set,å®ç°æ²¡æœ‰ä»€ä¹ˆç‰¹åˆ«çš„ã€‚
```java
    public static <E> Set<E> newSetFromMap(Map<E, Boolean> map) {
        return new SetFromMap<>(map);
    }
```
## 22.è½¬æ¢æˆåè¿›å…ˆå‡ºé˜Ÿåˆ—ï¼ˆasLifoQueueï¼‰
ä¼ å‚æ•°ä¸ºåŒå‘é˜Ÿåˆ—ï¼Œæ˜¯å…ˆè¿›å…ˆå‡ºçš„ï¼Œè½¬æ¢ä¹‹åï¼Œæˆä¸ºåè¿›å…ˆå‡ºé˜Ÿåˆ—ï¼Œä¹Ÿå°±æ˜¯å†è°ƒç”¨add()æ–¹æ³•ï¼Œä¼šæ’å…¥åœ¨é˜Ÿåˆ—çš„æœ€å‰é¢ã€‚
```java
    public static <T> Queue<T> asLifoQueue(Deque<T> deque) {
        return new AsLIFOQueue<>(deque);
    }
```
# å››ã€æ€»ç»“
`Collections`è¿™ä¸ªç±»å°±æ˜¯ä¸ªå·¥å…·ç±»ï¼Œä¸»è¦çš„æ–¹æ³•éƒ½æ˜¯è·å–çº¿ç¨‹å®‰å…¨é›†åˆï¼Œé›†åˆç±»å‹æ£€æŸ¥ï¼Œè½¬æ¢ï¼Œæˆªå–ï¼Œè·å–å•ä¸ªå¯¹è±¡çš„é›†åˆæˆ–è€…ç©ºé›†åˆï¼Œæ’åºï¼ŒæŸ¥æ‰¾ï¼Œæ—‹è½¬ï¼Œæ··æ’ç­‰ç­‰ï¼Œè¿™äº›éƒ½æ˜¯æˆ‘ä»¬æ—¥å¸¸çš„æ“ä½œï¼Œä½¿ç”¨é¢‘ç‡æ¯”è¾ƒé«˜ï¼Œæ‰€ä»¥éƒ½ç»™å°è£…æˆå·¥å…·ç±»äº†ã€‚
é‡Œé¢å¾ˆå¤šåœ°æ–¹éƒ½æ ¹æ®é˜ˆå€¼æˆ–è€…ç±»å‹æ¥ä½¿ç”¨ä¸åŒçš„ç´¢å¼•éå†æˆ–è€…è¿­ä»£å™¨éå†ï¼Œé‡Œé¢æ¯”è¾ƒåå¿ƒ`List`ï¼Œå¤§å¤šéƒ½æ˜¯`List`ç›¸å…³çš„å‘¢...
çœ‹çœ‹æºç ä¹ŸæŒºå¥½çš„ï¼Œæœ‰æ—¶å€™çŸ¥é“çš„è¶Šå¤šï¼Œæ„Ÿè§‰è‡ªå·±ä¸çŸ¥é“çš„è¶Šå¤šã€‚ä¸çŸ¥é“è‡ªå·±ä¸çŸ¥é“ï¼Œæ‰æ˜¯æœ€å¤§çš„é˜»ç¢ï¼Œç»§ç»­åŠ æ²¹ğŸ’ªğŸ’ªğŸ’ª

**ã€ä½œè€…ç®€ä»‹ã€‘**ï¼š
ç§¦æ€€ï¼Œå…¬ä¼—å·ã€**ç§¦æ€€æ‚è´§åº—**ã€‘ä½œè€…ï¼ŒæŠ€æœ¯ä¹‹è·¯ä¸åœ¨ä¸€æ—¶ï¼Œå±±é«˜æ°´é•¿ï¼Œçºµä½¿ç¼“æ…¢ï¼Œé©°è€Œä¸æ¯ã€‚è¿™ä¸ªä¸–ç•Œå¸Œæœ›ä¸€åˆ‡éƒ½å¾ˆå¿«ï¼Œæ›´å¿«ï¼Œä½†æ˜¯æˆ‘å¸Œæœ›è‡ªå·±èƒ½èµ°å¥½æ¯ä¸€æ­¥ï¼Œå†™å¥½æ¯ä¸€ç¯‡æ–‡ç« ï¼ŒæœŸå¾…å’Œä½ ä»¬ä¸€èµ·äº¤æµã€‚

æ­¤æ–‡ç« ä»…ä»£è¡¨è‡ªå·±ï¼ˆæœ¬èœé¸Ÿï¼‰å­¦ä¹ ç§¯ç´¯è®°å½•ï¼Œæˆ–è€…å­¦ä¹ ç¬”è®°ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»ä½œè€…æ ¸å®åˆ é™¤ã€‚äººæ— å®Œäººï¼Œæ–‡ç« ä¹Ÿä¸€æ ·ï¼Œæ–‡ç¬”ç¨šå«©ï¼Œåœ¨ä¸‹ä¸æ‰ï¼Œå‹¿å–·ï¼Œå¦‚æœæœ‰é”™è¯¯ä¹‹å¤„ï¼Œè¿˜æœ›æŒ‡å‡ºï¼Œæ„Ÿæ¿€ä¸å°½~ 


![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png)