[TOC]
# 1.Vectorä»‹ç»
`Vector`å’Œå‰é¢è¯´çš„`ArrayList`å¾ˆæ˜¯ç±»ä¼¼ï¼Œè¿™é‡Œè¯´çš„ä¹Ÿæ˜¯1.8ç‰ˆæœ¬ï¼Œå®ƒæ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼Œä½†æ˜¯æœ¬è´¨ä¸Šåº•å±‚ä¹Ÿæ˜¯æ•°ç»„å®ç°çš„ã€‚åŒæ ·ç»§æ‰¿`AbstractList`ï¼Œå®ç°äº†`List`,`RandomAcess`,`Cloneable`, `java.io.Serializable`æ¥å£ã€‚å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š
- æä¾›éšæœºè®¿é—®çš„åŠŸèƒ½ï¼šå®ç°`RandomAcess`æ¥å£ï¼Œè¿™ä¸ªæ¥å£ä¸»è¦æ˜¯ä¸º`List`æä¾›å¿«é€Ÿè®¿é—®çš„åŠŸèƒ½ï¼Œä¹Ÿå°±æ˜¯é€šè¿‡å…ƒç´ çš„ç´¢å¼•ï¼Œå¯ä»¥å¿«é€Ÿè®¿é—®åˆ°ã€‚
- å¯å…‹éš†ï¼šå®ç°äº†`Cloneable`æ¥å£
- æ˜¯ä¸€ä¸ªæ”¯æŒæ–°å¢ï¼Œåˆ é™¤ï¼Œä¿®æ”¹ï¼ŒæŸ¥è¯¢ï¼Œéå†ç­‰åŠŸèƒ½ã€‚
- å¯åºåˆ—åŒ–å’Œååºåˆ—åŒ–
- å®¹é‡ä¸å¤Ÿï¼Œå¯ä»¥è§¦å‘è‡ªåŠ¨æ‰©å®¹
- **æœ€å¤§çš„ç‰¹ç‚¹æ˜¯ï¼šçº¿ç¨‹å®‰å…¨çš„*ï¼Œç›¸å½“äºçº¿ç¨‹å®‰å…¨çš„`ArrayList`ã€‚

![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201105233415.png)

å®šä¹‰æºç å¦‚ä¸‹ï¼š
```  java
public class Vector<E>
    extends AbstractList<E>
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable{

    }
```


# 2. æˆå‘˜å˜é‡
åº•å±‚æ˜¯æ•°ç»„ï¼Œå¢åŠ å…ƒç´ ï¼Œæ•°ç»„ç©ºé—´ä¸å¤Ÿçš„æ—¶å€™ï¼Œéœ€è¦æ‰©å®¹ã€‚

- elementDataï¼šçœŸæ­£ä¿å­˜æ•°æ®çš„æ•°ç»„
- elementCountï¼šå®é™…å…ƒç´ ä¸ªæ•°
- capacityIncrementï¼šå®¹é‡å¢åŠ ç³»æ•°ï¼Œå°±æ˜¯æ‰©å®¹çš„æ—¶å€™å¢åŠ çš„å®¹é‡
- serialVersionUIDï¼šåºåˆ—åŒ–id
```  java
    // çœŸæ­£ä¿å­˜æ•°æ®çš„æ•°ç»„
    protected Object[] elementData;

    // å…ƒç´ ä¸ªæ•°
    protected int elementCount;

    //å®¹é‡å¢åŠ ç³»æ•°
    protected int capacityIncrement;
    // åºåˆ—åŒ–id
    private static final long serialVersionUID = -2767605614048989439L;
```
# 3. æ„é€ å‡½æ•°
`Vector`ä¸€å…±æœ‰å››ä¸ªæ„é€ å‡½æ•°ï¼š
- æŒ‡å®šå®¹é‡å’Œå¢é•¿ç³»æ•°
- æŒ‡å®šå®¹é‡
- ä¸æŒ‡å®šï¼Œä½¿ç”¨é»˜è®¤å®¹é‡å€¼10
- æŒ‡å®šé›†åˆåˆå§‹åŒ–


1.æŒ‡å®šå®¹é‡å’Œå¢é•¿ç³»æ•°æ„é€ å‡½æ•°
```java
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        // éæ³•åˆ¤æ–­
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        // åˆå§‹åŒ–æ•°ç»„
        this.elementData = new Object[initialCapacity];
        // æŒ‡å®šå¢é•¿ç³»æ•°
        this.capacityIncrement = capacityIncrement;
    }
```
2.æŒ‡å®šåˆå§‹åŒ–å®¹é‡ï¼Œå¢é•¿ç³»æ•°é»˜è®¤ä¸º0
```java
    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }
```

3.ä»€ä¹ˆéƒ½ä¸æŒ‡å®šï¼Œé»˜è®¤ç»™çš„å®¹é‡æ˜¯10ï¼š
```  java
    public Vector() {
        this(10);
    }
```

4.æŒ‡å®šé›†åˆåˆå§‹åŒ–ï¼š
```  java
    public Vector(Collection<? extends E> c) {
        // è½¬æ¢æˆä¸ºæ•°ç»„
        Object[] a = c.toArray();
        // å¤§å°ä¸ºæ•°ç»„çš„å¤§å°
        elementCount = a.length;
        // å¦‚æœæ˜¯ArrayListï¼Œåˆ™ç›´æ¥å¤åˆ¶
        if (c.getClass() == ArrayList.class) {
            elementData = a;
        } else {
            // å¦åˆ™éœ€è¦è¿›è¡Œæ‹·è´
            elementData = Arrays.copyOf(a, elementCount, Object[].class);
        }
    }
```

# 4. å¸¸ç”¨æ–¹æ³•
## 4.1 å¢åŠ 
å¢åŠ å…ƒç´ ï¼Œé»˜è®¤æ˜¯åœ¨æœ€åæ·»åŠ ï¼Œå¦‚æœå®¹é‡ä¸å¤Ÿçš„æ—¶å€™ä¼šè§¦å‘æ‰©å®¹æœºåˆ¶ã€‚
```java
    public synchronized void addElement(E obj) {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // ç¡®ä¿å®¹é‡è¶³å¤Ÿï¼ˆå¦‚æœéœ€è¦ï¼Œé‡Œé¢ä¼šæœ‰æ‰©å®¹ï¼Œå¤åˆ¶æ“ä½œï¼‰
        ensureCapacityHelper(elementCount + 1);
        // å°†æ–°å…ƒç´ æ”¾åœ¨æœ€åä¸€ä¸ªå…ƒç´ ï¼Œä¸ªæ•°å¢åŠ 
        elementData[elementCount++] = obj;
    }
```
é‚£ä¹ˆå®ƒæ˜¯å¦‚ä½•ç¡®ä¿å®¹é‡çš„å‘¢ï¼Ÿ
å¯ä»¥çœ‹åˆ°`ensureCapacityHelper()`é‡Œé¢åˆ¤æ–­å¢åŠ åçš„å…ƒç´ ä¸ªæ•°æ˜¯å¦å¤§äºç°åœ¨æ•°ç»„çš„é•¿åº¦ï¼Œå¦‚æœä¸æ»¡è¶³ï¼Œå°±éœ€è¦æ‰©å®¹ã€‚è°ƒç”¨`grow()`å‡½æ•°æ‰©å®¹ã€‚
```java
    private void ensureCapacityHelper(int minCapacity) {
        // overflow-conscious code
        if (minCapacity - elementData.length > 0)
            grow(minCapacity);
    }
    // æ‰©å®¹ï¼Œä¼ å…¥çš„æ˜¯éœ€è¦æœ€å°çš„å®¹é‡
    private void grow(int minCapacity) {
        // overflow-conscious code
        // ä»¥å‰çš„å®¹é‡
        int oldCapacity = elementData.length;
        // ç°åœ¨çš„å®¹é‡ï¼Œæ˜¯ä»¥å‰çš„å®¹é‡åŠ ä¸Šæ‰©å±•ç³»æ•°ï¼Œå¦‚æœæ‰©å±•ç³»æ•°å°äºç­‰äº0ï¼Œé‚£ä¹ˆï¼Œå°±æ˜¯ä»¥å‰çš„å®¹é‡çš„ä¸¤å€
        int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                         capacityIncrement : oldCapacity);
        // å¦‚æœæ–°çš„å®¹é‡å¤§äºæœ€å°éœ€è¦å®¹é‡ï¼Œå°±æ»¡è¶³äº†
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        // å¦‚æœæ–°çš„å®¹é‡æ¯”æœ€å¤§çš„å®¹é‡è¿˜è¦å¤§ï¼ˆè™šæ‹Ÿæœºçš„æ•°ç»„å¤§å°æ˜¯æœ‰æœ€å¤§å€¼çš„ï¼‰
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            // éœ€è¦å¤„ç†æŠŠæœ€å¤§çš„å®¹é‡é™ä½ä¸€äº›
            newCapacity = hugeCapacity(minCapacity);
        // æ‹·è´æ•°æ®
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
```
åœ¨æŒ‡å®šçš„ç´¢å¼•indexï¼Œæ’å…¥æ•°æ®ï¼Œå®é™…ä¸Šè°ƒç”¨çš„æ˜¯`insertElementAt(element, index)`.
```java
    public void add(int index, E element) {
        insertElementAt(element, index);
    }
    // è°ƒç”¨æ’å…¥å…ƒç´ çš„å‡½æ•°
    public synchronized void insertElementAt(E obj, int index) {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // åˆ¤æ–­ç´¢å¼•æ˜¯å¦éæ³•
        if (index > elementCount) {
            throw new ArrayIndexOutOfBoundsException(index
                                                     + " > " + elementCount);
        }
        // ç¡®ä¿å®¹é‡è¶³å¤Ÿ
        ensureCapacityHelper(elementCount + 1);
        // æ‹·è´æ•°æ®ï¼Œå°†åé¢çš„å…ƒç´ ï¼Œå¾€åç§»åŠ¨ä¸€ä½
        System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
        // å°†å®é™…çš„æ•°æ®æ’å…¥
        elementData[index] = obj;
        // ä¸ªæ•°å¢åŠ 
        elementCount++;
    }    
```

å°†ä¸€ä¸ªé›†åˆæ‰€æœ‰å…ƒç´ æ·»åŠ è¿›å»ï¼š
```java
    public synchronized boolean addAll(Collection<? extends E> c) {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // è½¬æˆæ•°ç»„
        Object[] a = c.toArray();
        // æ•°ç»„çš„é•¿åº¦
        int numNew = a.length;
        // ç¡®ä¿å®¹é‡è¶³å¤Ÿ
        ensureCapacityHelper(elementCount + numNew);
        // æ‹·è´
        System.arraycopy(a, 0, elementData, elementCount, numNew);
        // æ›´æ–°ä¸ªæ•°
        elementCount += numNew;
        // è¿”å›æ·»åŠ çš„æ•°ç»„æ˜¯ä¸æ˜¯æœ‰æ•°æ®
        return numNew != 0;
    }
```
æŒ‡å®šindexï¼Œæ’å…¥ä¸€ä¸ªé›†åˆï¼Œå’Œå‰é¢ä¸ä¸€æ ·çš„åœ°æ–¹åœ¨äºå¤åˆ¶ä¹‹å‰ï¼Œéœ€è¦è®¡ç®—å¾€åé¢ç§»åŠ¨å¤šå°‘ä½ï¼Œä¸æ˜¯ç”¨forå¾ªç¯å»æ’å…¥ï¼Œè€Œæ˜¯ä¸€æ¬¡æ€§ç§»åŠ¨å’Œå†™å…¥ã€‚
```java
    public synchronized boolean addAll(int index, Collection<? extends E> c) {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // åˆæ³•åˆ¤æ–­
        if (index < 0 || index > elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        // è½¬æ¢æ•°ç»„
        Object[] a = c.toArray();
        // æ’å…¥æ•°ç»„é•¿åº¦
        int numNew = a.length;
        // ç¡®ä¿æ•°ç»„çš„é•¿åº¦æ˜¯å¦åˆæ³•
        ensureCapacityHelper(elementCount + numNew);
        // ç§»åŠ¨çš„æ­¥é•¿è®¡ç®—
        int numMoved = elementCount - index;
        if (numMoved > 0)
            // ç§»åŠ¨åé¢çš„å…ƒç´ ï¼Œè…¾å‡ºä½ç½®ç»™æ’å…¥çš„å…ƒç´ 
            System.arraycopy(elementData, index, elementData, index + numNew,
                             numMoved);
        // æ’å…¥å…ƒç´ 
        System.arraycopy(a, 0, elementData, index, numNew);
        // æ›´æ–°ä¸ªæ•°
        elementCount += numNew;
        // æ’å…¥å…ƒç´ ä¸ªæ•°æ˜¯å¦ä¸º0
        return numNew != 0;
    }
```


## 4.2 åˆ é™¤

åˆ é™¤æŒ‡å®šå…ƒç´ 
```java
    public boolean remove(Object o) {
        return removeElement(o);
    }

    // å®é™…è°ƒç”¨çš„æ˜¯removeElement()
    public synchronized boolean removeElement(Object obj) {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // è·å–ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„å…ƒç´ ç¼©å½±
        int i = indexOf(obj);
        // ç´¢å¼•å¦‚æœæ»¡è¶³æ¡ä»¶
        if (i >= 0) {
            // å°†ç´¢å¼•ä¸ºiçš„å…ƒç´ ä»æ•°ç»„ä¸­ç§»é™¤
            removeElementAt(i);
            return true;
        }
        return false;
    }
    // æ“ä½œæ•°ç»„åˆ é™¤å…ƒç´ 
    public synchronized void removeElementAt(int index) {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // æ˜¯å¦åˆæ³•
        if (index >= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                     elementCount);
        }
        else if (index < 0) {
            throw new ArrayIndexOutOfBoundsException(index);
        }
        // indexåé¢çš„å…ƒç´ ä¸ªæ•°
        int j = elementCount - index - 1;
        if (j > 0) {
            // å¾€å‰é¢ç§»åŠ¨ä¸€ä½ï¼ˆå¤åˆ¶ï¼Œè¦†ç›–ï¼‰
            System.arraycopy(elementData, index + 1, elementData, index, j);
        }
        // æ›´æ–°ä¸ªæ•°
        elementCount--;
        // åŸæ¥æœ€åä¸€ä¸ªå…ƒç´ çš„ä½ç½®ç½®ç©º
        elementData[elementCount] = null; /* to let gc do its work */
    }
```

æŒ‰ç…§ç´¢å¼•åˆ é™¤å…ƒç´ ï¼š
```java
    public synchronized E remove(int index) {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // åˆæ³•æ€§åˆ¤æ–­
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        // ä¿å­˜åŸæ¥çš„æ•°æ®
        E oldValue = elementData(index);
        // ç§»åŠ¨çš„ä¸ªæ•°
        int numMoved = elementCount - index - 1;
        // å¦‚æœç§»åŠ¨ä¸ªæ•°å¤§äº0
        if (numMoved > 0)
            // åé¢çš„å…ƒç´ å¾€å‰é¢ç§»åŠ¨ä¸€ä½ï¼Œèµ‹å€¼ï¼Œè¦†ç›–
            System.arraycopy(elementData, index+1, elementData, index,
                             numMoved);
        // æœ€åä¸€ä¸ªå…ƒç´ ç½®ç©º
        elementData[--elementCount] = null; // Let gc do its work
        // è¿”å›æ—§çš„å…ƒç´ 
        return oldValue;
    }
```
## 4.3 ä¿®æ”¹
ä¸‹é¢ä¸¤ä¸ªsetå‡½æ•°éƒ½æ˜¯ï¼Œä¿®æ”¹ç´¢å¼•ä¸ºindexçš„å…ƒç´ ï¼ŒåŒºåˆ«å°±æ˜¯ä¸€ä¸ªä¼šè¿”å›æ—§çš„å…ƒç´ ï¼Œä¸€ä¸ªä¸ä¼šè¿”å›æ—§çš„å…ƒç´ ã€‚
```java
    public synchronized E set(int index, E element) {
        // åˆæ³•æ€§åˆ¤æ–­
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        // å–å‡ºæ—§çš„å…ƒç´ 
        E oldValue = elementData(index);
        // æ›´æ–°
        elementData[index] = element;
        // è¿”å›æ—§çš„å…ƒç´ 
        return oldValue;
    }
    public synchronized void setElementAt(E obj, int index) {
        // åˆæ³•å“¦æ€§åˆ¤æ–­
        if (index >= elementCount) {
            throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                     elementCount);
        }
        // ç›´æ¥æ›´æ–°
        elementData[index] = obj;
    }
```
## 4.4 æŸ¥è¯¢
```java
    public synchronized E get(int index) {
        // åˆæ³•åˆ¤æ–­
        if (index >= elementCount)
            throw new ArrayIndexOutOfBoundsException(index);
        // è¿”å›æ•°ç»„çš„å…ƒç´ 
        return elementData(index);
    }
```
è·å–ç¬¬ä¸€ä¸ªå…ƒç´ ï¼š
```java
    public synchronized E firstElement() {
        if (elementCount == 0) {
            throw new NoSuchElementException();
        }
        return elementData(0);
    }
```
è·å–æœ€åä¸€ä¸ªå…ƒç´ ï¼š
```java
    public synchronized E lastElement() {
        if (elementCount == 0) {
            throw new NoSuchElementException();
        }
        return elementData(elementCount - 1);
    }
    E elementData(int index) {
        return (E) elementData[index];
    }
```
## 4.5 å…¶ä»–å¸¸ç”¨å‡½æ•°
 å°†å…ƒç´ æ‹·è´è¿›æ•°ç»„ä¸­ï¼š
 ```java
    public synchronized void copyInto(Object[] anArray) {
        System.arraycopy(elementData, 0, anArray, 0, elementCount);
    }
 ```

 æ‰‹åŠ¨ç¼©å®¹ï¼Œå…¶å®å°±æ˜¯å°†é‡Œé¢çš„æ•°ç»„å¤åˆ¶åˆ°ä¸€ä¸ªæ›´å°çš„æ•°ç»„ï¼Œæ›´æ–°æ•°ç»„å¼•ç”¨å³å¯ã€‚
 ```java
    public synchronized void trimToSize() {
        // ä¿®æ”¹æ¬¡æ•°å¢åŠ 
        modCount++;
        // è·å–æ•°ç»„çš„é•¿åº¦
        int oldCapacity = elementData.length;
        // æ•°ç»„é•¿åº¦å¤§äºçœŸå®çš„å®¹é‡ï¼Œè¯´æ˜æœ‰å¯ä»¥ç¼©å®¹çš„ç©ºé—´
        if (elementCount < oldCapacity) {
            // å¤åˆ¶åˆ°æ–°çš„æ•°ç»„
            elementData = Arrays.copyOf(elementData, elementCount);
        }
    }
 ```

 ä¿è¯å®¹é‡çš„å‡½æ•°ï¼Œå…¶å®ç›¸å½“äºæ‰‹åŠ¨æ‰©å®¹ï¼Œå‚æ•°æ˜¯æ‰€éœ€è¦çš„æœ€å°çš„å®¹é‡,é‡Œé¢è°ƒç”¨çš„`ensureCapacityHelper()`åœ¨ä¸Šé¢`add()`å‡½æ•°è§£æçš„æ—¶å€™å·²ç»è¯´è¿‡äº†ï¼Œä¸å†è§£æã€‚
 ```java
    public synchronized void ensureCapacity(int minCapacity) {
        if (minCapacity > 0) {
            modCount++;
            ensureCapacityHelper(minCapacity);
        }
    }
 ```
 æ‰‹åŠ¨å°†å…ƒç´ ä¸ªæ•°è®¾ç½®ä¸ºnewSize,åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯æ–°çš„sizeæ¯”ç°åœ¨çš„sizeè¿˜è¦å¤§ï¼Œå°±æ˜¯æƒ³åˆ°é‚£ä¸ªäºæŒ‡å®šå®¹é‡æ‰©å®¹ã€‚å¦å¤–ä¸€ç§æ˜¯ç›¸å½“äºç¼©å®¹ï¼Œä½†æ˜¯è¿™ä¸ªç¼©å®¹æ¯”è¾ƒç‰¹æ®Šï¼Œæ€»çš„å®¹é‡å®é™…ä¸Šæ²¡æœ‰å˜åŒ–ï¼Œåªæ˜¯å°†é‡Œé¢å¤šä½™çš„å…ƒç´ ç½®ä¸ºnullã€‚
 ```java
    public synchronized void setSize(int newSize) {
        modCount++;
        if (newSize > elementCount) {
            // æ‰©å®¹
            ensureCapacityHelper(newSize);
        } else {
            for (int i = newSize ; i < elementCount ; i++) {
                // å°†è¶…å‡ºä¸ªæ•°çš„å…ƒç´ è®¾ç½®ä¸ºnull
                elementData[i] = null;
            }
        }
        elementCount = newSize;
    }
 ```

è·å–å®¹é‡ï¼š
```java
    public synchronized int capacity() {
        return elementData.length;
    }
```

è·å–é‡Œé¢çœŸå®çš„å…ƒç´ ä¸ªæ•°ï¼š
```java
    public synchronized int size() {
        return elementCount;
    }
```

å®¹å™¨æ˜¯ä¸æ˜¯ä¸ºç©ºï¼š
```java
    public synchronized boolean isEmpty() {
        return elementCount == 0;
    }
```

è¿”å›æšä¸¾ç±»å‹çš„å…ƒç´ è¿­ä»£å™¨ï¼Œè¿™æ˜¯ä¸€ä¸ªæœ‰æ„æ€çš„æ–¹æ³•ï¼Œç›¸å½“äºç”¨æšä¸¾åŒ…è£…äº†å½“å‰çš„å…ƒç´ ï¼Œ`Enumeration`æ˜¯ä¸€ä¸ªæ¥å£ï¼Œè¿™ä¸ªæ¥å£æœ‰ä¸¤ä¸ªæ–¹æ³•ï¼Œä¸€ä¸ªæ˜¯`hasMoreElements()`,è¡¨ç¤ºæ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚ä¸€ä¸ªæ˜¯`nextElement()`ï¼Œè·å–ä¸‹ä¸€ä¸ªå…ƒç´ ã€‚
```java
    public Enumeration<E> elements() {
        return new Enumeration<E>() {
            int count = 0;
            // é‡å†™æ–¹æ³•ï¼Œæ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 
            public boolean hasMoreElements() {
                return count < elementCount;
            }

            public E nextElement() {
                // åŒæ­¥
                synchronized (Vector.this) {
                    if (count < elementCount) {
                        // è¿”å›ä¸‹ä¸€ä¸ªå…ƒç´ 
                        return elementData(count++);
                    }
                }
                throw new NoSuchElementException("Vector Enumeration");
            }
        };
    }
```

æ˜¯å¦åŒ…å«æŸä¸€ä¸ªå…ƒç´ ,å…¶å®é‡Œé¢æ˜¯è·å–å¯¹è±¡çš„ç´¢å¼•ï¼Œå¦‚æœç´¢å¼•å¤§äºç­‰äº0ï¼Œè¯æ˜å…ƒç´ åœ¨é‡Œé¢ï¼Œå¦åˆ™å…ƒç´ ä¸åœ¨é‡Œé¢ã€‚
```java
    public boolean contains(Object o) {
        return indexOf(o, 0) >= 0;
    }
```

è¿”å›å…ƒç´ çš„ç´¢å¼•,åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼Œä¸€ç§æ˜¯å…ƒç´ æ˜¯nullçš„æƒ…å†µï¼Œä¸èƒ½ä½¿ç”¨`equals()`æ–¹æ³•ï¼Œå¦ä¸€ç§æ˜¯énullï¼Œå¯ä»¥ç›´æ¥ä½¿ç”¨`equals()`æ–¹æ³•ã€‚
```java
    public int indexOf(Object o) {
        return indexOf(o, 0);
    }
    public synchronized int indexOf(Object o, int index) {
        if (o == null) {
            for (int i = index ; i < elementCount ; i++)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = index ; i < elementCount ; i++)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
```
è·å–å…ƒç´ æœ€åå‡ºç°çš„ç´¢å¼•ä½ç½®,å’Œå‰é¢ä¸€ä¸ªä¸ä¸€æ ·çš„æ˜¯ï¼Œè¿™ä¸ªéœ€è¦ä»æœ€åä¸€ä¸ªå…ƒç´ å¾€å‰é¢æŸ¥æ‰¾
```java
    public synchronized int lastIndexOf(Object o) {
        return lastIndexOf(o, elementCount-1);
    }
    public synchronized int lastIndexOf(Object o, int index) {
        if (index >= elementCount)
            throw new IndexOutOfBoundsException(index + " >= "+ elementCount);

        if (o == null) {
            for (int i = index; i >= 0; i--)
                if (elementData[i]==null)
                    return i;
        } else {
            for (int i = index; i >= 0; i--)
                if (o.equals(elementData[i]))
                    return i;
        }
        return -1;
    }
```
æ‹·è´å…ƒç´ ,æ•°ç»„é‡Œé¢çš„å…ƒç´ å…¶å®æ‹·è´çš„åªæ˜¯å¼•ç”¨ï¼Œå¦‚æœä¿®æ”¹æ–°çš„`Vector`é‡Œé¢çš„å¯¹è±¡çš„å±æ€§ï¼Œæ—§çš„ä¹Ÿä¼šè¢«ä¿®æ”¹ã€‚
```java
    public synchronized Object clone() {
        try {
            @SuppressWarnings("unchecked")
                Vector<E> v = (Vector<E>) super.clone();
            v.elementData = Arrays.copyOf(elementData, elementCount);
            v.modCount = 0;
            return v;
        } catch (CloneNotSupportedException e) {
            // this shouldn't happen, since we are Cloneable
            throw new InternalError(e);
        }
    }
```

æ¯”å¦‚ï¼š

```java
class Student {

    public  int age;

    public String name;


    public Student(int age, String name) {
        this.age = age;
        this.name = name;
    }

    @Override
    public String toString() {
        return "Student{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
public class Test {
    public static void main(String[] args) {
        Vector<Student> vector1 = new Vector<>();
        vector1.add(new Student(1,"sam"));

        Vector<Student> vector2 = (Vector<Student>) vector1.clone();
        vector2.get(0).name = "change name";
        System.out.println(vector2);
        System.out.println(vector1);
    }
```
è¾“å‡ºç»“æœå¦‚ä¸‹,å¯ä»¥çœ‹å‡ºå…¶å®ä¸¤ä¸ªé›†åˆé‡Œé¢çš„Studentè¿˜æ˜¯åŒä¸€ä¸ªå¯¹è±¡ã€‚
```  java
[Student{age=1, name='change name', score=0}]
[Student{age=1, name='change name', score=0}]
```

å°†å…ƒç´ è½¬æ¢æˆä¸ºæ•°ç»„ï¼ŒåŸç†ä¹Ÿæ˜¯ä¸€æ ·ï¼Œéƒ½æ˜¯æµ…æ‹·è´ï¼Œæ‹·è´çš„éƒ½æ˜¯å…ƒç´ å¯¹è±¡çš„å¼•ç”¨ã€‚
```java
    public synchronized Object[] toArray() {
        return Arrays.copyOf(elementData, elementCount);
    }
```
æŒ‡å®šæ•°ç»„ç±»å‹çš„æ‹·è´ï¼š
```java
    public synchronized <T> T[] toArray(T[] a) {
        if (a.length < elementCount)
            return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());

        System.arraycopy(elementData, 0, a, 0, elementCount);

        if (a.length > elementCount)
            a[elementCount] = null;

        return a;
    }
```
æˆªå–å‡ºæŸä¸€æ®µçš„å…ƒç´ é›†åˆ,è°ƒç”¨çš„æ˜¯çˆ¶ç±»çš„æ–¹æ³•
```java
    public synchronized List<E> subList(int fromIndex, int toIndex) {
        return Collections.synchronizedList(super.subList(fromIndex, toIndex),
                                            this);
    }
```
ç§»é™¤æŸä¸€æ®µç´¢å¼•çš„å…ƒç´ ,æˆ‘ä»¬å¯ä»¥çœ‹åˆ°é¦–å…ˆæ˜¯å°†åé¢çš„å…ƒç´ å¾€å‰é¢ç§»åŠ¨ï¼Œè¦†ç›–æ‰å‰é¢çš„å…ƒç´ ï¼Œç„¶åå°†åé¢çš„å…ƒç´ å‘ä½èµ‹å€¼ä¸ºnullã€‚
```java
    protected synchronized void removeRange(int fromIndex, int toIndex) {
        modCount++;
        int numMoved = elementCount - toIndex;
        // å¤åˆ¶åˆ°å‰é¢ä¸€æ®µï¼Œå°†è¢«ç§»é™¤çš„é‚£ä¸€æ®µè¦†ç›–ï¼Œç›¸å½“äºåé¢å…ƒç´ æ•´ä½“å‰ç§»
        System.arraycopy(elementData, toIndex, elementData, fromIndex,
                         numMoved);

        // Let gc do its work
        int newElementCount = elementCount - (toIndex-fromIndex);
        // åé¢çš„å‘ä½èµ‹å€¼ä¸ºnull
        while (elementCount != newElementCount)
            elementData[--elementCount] = null;
    }
```
è·å–æŒ‡å®šä½ç½®çš„è¿­ä»£å™¨ï¼š
`Vector`å’Œ`ArrayList`åŸºæœ¬å·®ä¸å¤šï¼Œéƒ½æ˜¯å®šä¹‰äº†ä¸‰ä¸ªè¿­ä»£å™¨ï¼š
- `Itr`:å®ç°æ¥å£`Iterator`ï¼Œæœ‰ç®€å•çš„åŠŸèƒ½ï¼šåˆ¤æ–­æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè·å–ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåˆ é™¤ï¼Œéå†å‰©ä¸‹çš„å…ƒç´ 
- `ListItr`:ç»§æ‰¿`Itr`ï¼Œå®ç°`ListIterator`ï¼Œåœ¨`Itr`çš„åŸºç¡€ä¸Šæœ‰äº†æ›´åŠ ä¸°å¯Œçš„åŠŸèƒ½ã€‚
- `VectorSpliterator`:å¯ä»¥åˆ†å‰²çš„è¿­ä»£å™¨ï¼Œä¸»è¦æ˜¯ä¸ºäº†åˆ†å‰²ä»¥é€‚åº”å¹¶è¡Œå¤„ç†ã€‚å’Œ`ArrayList`é‡Œé¢çš„`ArrayListSpliterator`ç±»ä¼¼ã€‚
```java
    // è¿”å›æŒ‡å®šindexä½ç½®çš„ListIterator
    public synchronized ListIterator<E> listIterator(int index) {
        if (index < 0 || index > elementCount)
            throw new IndexOutOfBoundsException("Index: "+index);
        return new ListItr(index);
    }
    // è¿”å›å¼€å§‹ä½ç½®çš„ListIterator
    public synchronized ListIterator<E> listIterator() {
        return new ListItr(0);
    }
    // è¿”å›Itr
    public synchronized Iterator<E> iterator() {
        return new Itr();
    }
    // è¿”å›VectorSpliterator
    public Spliterator<E> spliterator() {
        return new VectorSpliterator<>(this, null, 0, -1, 0);
    }
```

## 4.6 Lambdaè¡¨è¾¾å¼ç›¸å…³çš„æ–¹æ³•
 - forEachï¼šéå†å¤„ç†
 - removeIfï¼šæŒ‰ç…§æ¡ä»¶ç§»é™¤å…ƒç´ 
 - replaceAllï¼šç§»é™¤å…ƒç´ 
 - sortï¼šæ’åº

 åŸºæœ¬éƒ½æ˜¯å°†è¡Œä¸ºå½“æˆå‚æ•°ä¼ é€’åˆ°å‡½æ•°ä¸­è¿›è¡Œå¤„ç†ï¼Œé‡Œé¢å€¼å¾—ä¸€æçš„æ˜¯`removeIf()`ï¼Œé‡Œé¢æ˜¯å°†è¿‡æ»¤å™¨ä¼ é€’è¿›å»ï¼Œåœ¨é‡Œé¢æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ä½¿ç”¨äº†`BitSet`ï¼Œè¿™ä¸ªä¸œè¥¿æ¥ä¿å­˜äº†éœ€è¦ç§»é™¤çš„å…ƒç´ çš„ä¸‹æ ‡ï¼Œç»Ÿè®¡å®Œæˆä¹‹åï¼Œåé¢å†å–å‡ºæ¥è¿›è¡Œç§»é™¤æ“ä½œã€‚é‚£ä¹ˆè¿™ä¸ª`BitSet`æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿï¼Ÿï¼ŸğŸ¤”ğŸ¤”ğŸ¤”ğŸ¤”
 
> ä¸€ä¸ªBitsetç±»åˆ›å»ºä¸€ç§ç‰¹æ®Šç±»å‹çš„æ•°ç»„æ¥ä¿å­˜ä½å€¼ã€‚BitSetä¸­æ•°ç»„å¤§å°ä¼šéšéœ€è¦å¢åŠ ã€‚è¿™å’Œä½å‘é‡ï¼ˆvector of bitsï¼‰æ¯”è¾ƒç±»ä¼¼ã€‚
> è¿™æ˜¯ä¸€ä¸ªä¼ ç»Ÿçš„ç±»ï¼Œä½†å®ƒåœ¨Java 2ä¸­è¢«å®Œå…¨é‡æ–°è®¾è®¡ã€‚

è¿™æ ·ä¸€çœ‹å…¶å®å°±æ˜¯ä¸€ä¸ªä¿å­˜ä½å€¼çš„ç±»ï¼Œå¯ä»¥è®¾ç½®ä¸ºtrueï¼Œä¹Ÿå¯ä»¥å–å‡ºæ¥ï¼Œè¿™æ ·å°±æ¯”è¾ƒç¬¦åˆç°åœ¨çš„åœºæ™¯ï¼Œå…ˆéå†ä¸€æ¬¡ï¼ŒæŠŠéœ€è¦ç§»é™¤çš„å…ƒç´ ç”¨`BitSet`æ ‡è®°ä¸€ä¸‹ï¼Œç„¶åå†æ¬¡éå†çš„æ—¶å€™ï¼Œå°±å¤åˆ¶å…ƒç´ ï¼Œå°†è¿™äº›å‘ä½è¦†ç›–æ‰ï¼Œå°±å¯ä»¥äº†ã€‚
 
 ```java
    @Override
    public synchronized void forEach(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        final int expectedModCount = modCount;
        @SuppressWarnings("unchecked")
        final E[] elementData = (E[]) this.elementData;
        final int elementCount = this.elementCount;
        for (int i=0; modCount == expectedModCount && i < elementCount; i++) {
            // å¯¹æ¯ä¸€ä¸ªå…ƒç´ è¿›è¡Œå¤„ç†
            action.accept(elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public synchronized boolean removeIf(Predicate<? super E> filter) {
        Objects.requireNonNull(filter);
        // figure out which elements are to be removed
        // any exception thrown from the filter predicate at this stage
        // will leave the collection unmodified
        int removeCount = 0;
        final int size = elementCount;
        // æŒ‰ç…§å½“å‰çš„å¤§å°åˆ›å»ºä¸€ä¸ªä½å€¼ä¿å­˜BitSet
        final BitSet removeSet = new BitSet(size);
        final int expectedModCount = modCount;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            @SuppressWarnings("unchecked")
            final E element = (E) elementData[i];
            // å¦‚æœç¬¦åˆæ¡ä»¶
            if (filter.test(element)) {
                // å°†æŒ‡å®šç´¢å¼•å¤„çš„ä½è®¾ç½®ä¸º trueã€‚
                removeSet.set(i);
                // è®¡ç®—éœ€è¦ç§»é™¤çš„ä¸ªæ•°
                removeCount++;
            }
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }

        // shift surviving elements left over the spaces left by removed elements
        final boolean anyToRemove = removeCount > 0;
        if (anyToRemove) {
            // ç§»é™¤åçš„å¤§å°
            final int newSize = size - removeCount;
            for (int i=0, j=0; (i < size) && (j < newSize); i++, j++) {
                // è¿”å›ç¬¬ä¸€ä¸ªè®¾ç½®ä¸º false çš„ä½çš„ç´¢å¼•ï¼Œè¿™å‘ç”Ÿåœ¨æŒ‡å®šçš„èµ·å§‹ç´¢å¼•æˆ–ä¹‹åçš„ç´¢å¼•ä¸Šã€‚
                i = removeSet.nextClearBit(i);
                // å…ƒç´ å‰ç§»æ“ä½œï¼Œè¦†ç›–è¢«ç§»é™¤çš„å…ƒç´ çš„ä½ç½®
                elementData[j] = elementData[i];
            }
            // å°†åé¢çš„å…ƒç´ å‘ä½ç½®ä¸ºnull
            for (int k=newSize; k < size; k++) {
                elementData[k] = null;  // Let gc do its work
            }
            elementCount = newSize;
            if (modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
            modCount++;
        }

        return anyToRemove;
    }

    @Override
    @SuppressWarnings("unchecked")
    public synchronized void replaceAll(UnaryOperator<E> operator) {
        Objects.requireNonNull(operator);
        final int expectedModCount = modCount;
        final int size = elementCount;
        for (int i=0; modCount == expectedModCount && i < size; i++) {
            // operatoræ˜¯æ“ä½œï¼Œæ„æ€æ˜¯å°†æ”¹æ“ä½œåº”ç”¨äºé‡Œé¢çš„æ¯ä¸€ä¸ªå…ƒç´ 
            elementData[i] = operator.apply((E) elementData[i]);
        }
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }

    @SuppressWarnings("unchecked")
    @Override
    public synchronized void sort(Comparator<? super E> c) {
        final int expectedModCount = modCount;
        // åº•å±‚å…¶å®å°±æ˜¯è°ƒç”¨äº†æ•°ç»„çš„æ’åºæ–¹æ³•ï¼Œå°†æ¯”è¾ƒå™¨cä¼ é€’è¿›å»
        Arrays.sort((E[]) elementData, 0, elementCount, c);
        if (modCount != expectedModCount) {
            throw new ConcurrentModificationException();
        }
        modCount++;
    }
 ```

## 4.7 å¦‚ä½•éå†å…ƒç´ 
éå†æ–¹æ³•æœ‰ä¸€ä¸‹å‡ ç§ï¼šå€¼å¾—ä¸€è¯´çš„æ˜¯ä½¿ç”¨è¿­ä»£å™¨å’Œä½¿ç”¨æšä¸¾è¿­ä»£å™¨è¿›è¡Œéå†ã€‚
```java
        Vector<String> myVector = new Vector<>();
        
        // ç¬¬ä¸€ç§
        for(String item:myVector){
            System.out.println(item);
        }
        // ç¬¬äºŒç§
        myVector.forEach(item-> System.out.println(item));
        myVector.stream().forEach(new Consumer<String>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        });
        
        // ç¬¬ä¸‰ç§
        for(int index = 0;index<myVector.size();index++){
            System.out.println(myVector.get(index));
        }
        
        // ç¬¬å››ç§
        Iterator<String> iterator = myVector.iterator();
        while(iterator.hasNext()){
            System.out.println((String)iterator.next());
        }
        
        // ç¬¬äº”ç§
        Enumeration<String> enumeration = myVector.elements();
        while(enumeration.hasMoreElements()){
            System.out.println(enumeration.nextElement().toString());
        }
```

# 5.åºåˆ—åŒ–å’Œååºåˆ—åŒ–
å…¶å®æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å®ƒçš„å…ƒç´ é›†åˆæ²¡æœ‰ç”¨`transient`æ¥ä¿®é¥°,å’Œ`ArrayList`æœ‰æ‰€ä¸åŒã€‚
```java
    protected Object[] elementData;
```
ä½†æ˜¯å®ƒä¹Ÿé‡å†™äº†åºåˆ—åŒ–çš„`readObject()`å’Œ`writeObject()`ä¸¤ä¸ªæ–¹æ³•ã€‚å’Œ`ArrayList`ä¸åŒçš„æ˜¯ï¼Œåºåˆ—åŒ–çš„æ—¶å€™å°†æ‰€æœ‰çš„æ•°ç»„é‡Œé¢çš„å…ƒç´ éƒ½åºåˆ—åŒ–äº†ï¼Œæ›´åŠ å ç”¨ç©ºé—´ã€‚
åºåˆ—åŒ–çš„æ—¶å€™ä¼šåºåˆ—åŒ–ä¸‰ä¸ªä¸œè¥¿ï¼š
- capacityIncrement:æ‰©å®¹å¢é•¿ç³»æ•°
- elementCount:å…ƒç´ ä¸ªæ•°
- elementData: æ•°ç»„å…ƒç´ 

```java
    private void readObject(ObjectInputStream in)
            throws IOException, ClassNotFoundException {
        ObjectInputStream.GetField gfields = in.readFields();
        int count = gfields.get("elementCount", 0);
        Object[] data = (Object[])gfields.get("elementData", null);
        if (count < 0 || data == null || count > data.length) {
            throw new StreamCorruptedException("Inconsistent vector internals");
        }
        elementCount = count;
        elementData = data.clone();
    }
    private void writeObject(java.io.ObjectOutputStream s)
            throws java.io.IOException {
        final java.io.ObjectOutputStream.PutField fields = s.putFields();
        final Object[] data;
        synchronized (this) {
            // å¢é•¿ç³»æ•°
            fields.put("capacityIncrement", capacityIncrement);
            // ä¸ªæ•°
            fields.put("elementCount", elementCount);
            // æ•°ç»„
            data = elementData.clone();
        }
        fields.put("elementData", data);
        s.writeFields();
    }
```

# 6.è¿­ä»£å™¨
`Vector`å’Œ`ArrayList`åŸºæœ¬å·®ä¸å¤šï¼Œéƒ½æ˜¯å®šä¹‰äº†ä¸‰ä¸ªè¿­ä»£å™¨ï¼š
- `Itr`:å®ç°æ¥å£`Iterator`ï¼Œæœ‰ç®€å•çš„åŠŸèƒ½ï¼šåˆ¤æ–­æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè·å–ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåˆ é™¤ï¼Œéå†å‰©ä¸‹çš„å…ƒç´ 
- `ListItr`:ç»§æ‰¿`Itr`ï¼Œå®ç°`ListIterator`ï¼Œåœ¨`Itr`çš„åŸºç¡€ä¸Šæœ‰äº†æ›´åŠ ä¸°å¯Œçš„åŠŸèƒ½ã€‚
- `VectorSpliterator`:å¯ä»¥åˆ†å‰²çš„è¿­ä»£å™¨ï¼Œä¸»è¦æ˜¯ä¸ºäº†åˆ†å‰²ä»¥é€‚åº”å¹¶è¡Œå¤„ç†ã€‚å’Œ`ArrayList`é‡Œé¢çš„`ArrayListSpliterator`ç±»ä¼¼ã€‚

## 6.1 Itr
`Itr`è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒåˆçº§çš„è¿­ä»£å™¨ï¼Œå®ç°äº†`Iterator`æ¥å£ï¼Œæœ‰åˆ¤æ–­æ˜¯å¦æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œè®¿é—®ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œåˆ é™¤å…ƒç´ çš„æ–¹æ³•ä»¥åŠéå†å¯¹æ¯ä¸€ä¸ªå…ƒç´ å¤„ç†çš„æ–¹æ³•ã€‚
é‡Œé¢æœ‰ä¸¤ä¸ªæ¯”è¾ƒé‡è¦çš„å±æ€§ï¼š
- cursorï¼šä¸‹ä¸€ä¸ªå³å°†è®¿é—®çš„å…ƒç´ ä¸‹æ ‡
- lastRetï¼šä¸Šä¸€ä¸ªè¿”å›çš„å…ƒç´ ä¸‹æ ‡ï¼Œåˆå§‹åŒ–ä¸º-1

ä¸¤ä¸ªé‡è¦çš„æ–¹æ³•ï¼š
- next():è·å–ä¸‹ä¸€ä¸ªå…ƒç´ 
- remove():ç§»é™¤å½“å‰å…ƒç´ ï¼Œéœ€è¦åœ¨next()æ–¹æ³•è°ƒç”¨ä¹‹åï¼Œæ‰èƒ½è°ƒç”¨ï¼Œè¦ä¸ä¼šæŠ¥é”™ã€‚

å’Œ`ArrayList`é‡Œé¢å®šä¹‰çš„åŸºæœ¬å·®ä¸å¤šï¼Œé™¤äº†è¿™é‡Œé¢å…¶å®åŠ ä¸ŠåŒæ­¥ï¼Œå› ä¸ºè¦åšåˆ°çº¿ç¨‹å®‰å…¨ã€‚
```java
    private class Itr implements Iterator<E> {
        // ä¸‹ä¸€ä¸ªå³å°†è¿”å›çš„å…ƒç´ index
        int cursor;       
        // ä¸Šä¸€ä¸ªè¿”å›çš„indexï¼Œ-1åˆ™è¡¨ç¤ºæ²¡æœ‰
        int lastRet = -1; 
        int expectedModCount = modCount;

        // æ˜¯å¦è¿˜æœ‰ä¸‹ä¸€ä¸ªå…ƒç´ 
        public boolean hasNext() {
            return cursor != elementCount;
        }

        // è·å–ä¸‹ä¸€ä¸ªè¿”å›çš„å…ƒç´ 
        public E next() {
            // åŒæ­¥
            synchronized (Vector.this) {
                checkForComodification();
                // ç”±äºcursoræœ¬èº«å°±æ˜¯ä¸‹ä¸€ä¸ªå…ƒç´ çš„ä¸‹æ ‡ï¼Œæ‰€ä»¥è¿™ä¸ªå€¼ç›´æ¥å–åˆ°ï¼Œè¿”å›å°±å¯ä»¥ï¼Œç”¨iä¿å­˜ä¸€ä¸‹
                int i = cursor;
                if (i >= elementCount)
                    throw new NoSuchElementException();
                // ä¸‹ä¸€ä¸ªè¿”å›çš„indexæ›´æ–°
                cursor = i + 1;
                // è¿”å›iä½ç½®çš„å€¼ï¼Œæ›´æ–°lastRetä½ç½®
                return elementData(lastRet = i);
            }
        }

        // ç§»é™¤å…ƒç´ 
        public void remove() {
            if (lastRet == -1)
                throw new IllegalStateException();
            // åŒæ­¥
            synchronized (Vector.this) {
                checkForComodification();
                // è°ƒç”¨Vectorçš„ç§»é™¤æ–¹æ³•
                Vector.this.remove(lastet);
                expectedModCount = modCount;
            }
            // åˆ é™¤äº†å½“å‰çš„å…ƒç´ ï¼Œç›¸å½“äºè¿­ä»£å™¨å€’é€€äº†ä¸€æ­¥
            cursor = lastRet;
            // ä¸Šæ¬¡è¿”å›çš„å…ƒç´ ä¸‹æ ‡æ›´æ–°ä¸º-1ï¼Œå› ä¸ºç§»é™¤äº†
            lastRet = -1;
        }

        // éå†å¤„ç†å‰©ä¸‹çš„å…ƒç´ 
        @Override
        public void forEachRemaining(Consumer<? super E> action) {
            Objects.requireNonNull(action);
            synchronized (Vector.this) {
                final int size = elementCount;
                int i = cursor;
                if (i >= size) {
                    return;
                }
        @SuppressWarnings("unchecked")
                final E[] elementData = (E[]) Vector.this.elementData;
                if (i >= elementData.length) {
                    throw new ConcurrentModificationException();
                }
                // å¯¹å‰©ä¸‹çš„å…ƒç´ æŒ¨ä¸ªå¤„ç†
                while (i != size && modCount == expectedModCount) {
                    action.accept(elementData[i++]);
                }
                // update once at end of iteration to reduce heap write traffic
                cursor = i;
                lastRet = i - 1;
                checkForComodification();
            }
        }
        // æ£€æŸ¥æ˜¯å¦è¢«ä¿®æ”¹
        final void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }
```

## 6.2 ListItr
æ‹“å±•äº†`Itr`çš„åŠŸèƒ½ï¼Œå¤šäº†å‡ ä¸ªæ–¹æ³•ã€‚
ä¸»è¦å¢åŠ çš„åŠŸèƒ½æœ‰ï¼š
- æ ¹æ®indexè·å–è¯¥ä½ç½®çš„è¿­ä»£å™¨
- åˆ¤æ–­æ˜¯å¦æœ‰å‰é¢çš„å…ƒç´ 
- è·å–ä¸‹ä¸€ä¸ªè¿”å›å…ƒç´ çš„ä¸‹æ ‡
- è·å–ä¸Šä¸€ä¸ªè¿”å›å…ƒç´ çš„ä¸‹é¢
- è·å–ä¸Šä¸€ä¸ªå…ƒç´ 
- æ›´æ–°å…ƒç´ 
- å¢åŠ å…ƒç´ 

åŸºæœ¬å’Œ`ArrayList`çš„ä¹Ÿä¸€æ ·ï¼Œä¹Ÿå°±ä¿®æ”¹çš„æ–¹æ³•ä¸ŠåŠ ä¸Šäº†`synchronized`å…³é”®å­—è¿›è¡ŒåŒæ­¥ã€‚
```java
    final class ListItr extends Itr implements ListIterator<E> {
        ListItr(int index) {
            super();
            cursor = index;
        }
        // æ˜¯å¦æœ‰ä¸Šä¸€ä¸ªå…ƒç´ 
        public boolean hasPrevious() {
            return cursor != 0;
        }
        // ä¸‹ä¸€ä¸ªå…ƒç´ ä¸‹æ ‡
        public int nextIndex() {
            return cursor;
        }
        // ä¸Šä¸€ä¸ªå…ƒç´ ä¸‹æ ‡
        public int previousIndex() {
            return cursor - 1;
        }

        // è·å–ä¸Šä¸€ä¸ªå…ƒç´ 
        public E previous() {
            // åŒæ­¥
            synchronized (Vector.this) {
                checkForComodification();
                int i = cursor - 1;
                if (i < 0)
                    throw new NoSuchElementException();
                // å€’é€€äº†ä¸€æ­¥ï¼Œæ‰€ä»¥cursorç›¸å½“äºå‡1
                cursor = i;
                // æ›´æ–°ä¸Šä¸€ä¸ªå…ƒç´ index
                return elementData(lastRet = i);
            }
        }

        // æ›´æ–°å…ƒç´ 
        public void set(E e) {
            if (lastRet == -1)
                throw new IllegalStateException();
            synchronized (Vector.this) {
                checkForComodification();
                Vector.this.set(lastRet, e);
            }
        }

        // æ’å…¥å…ƒç´ 
        public void add(E e) {
            int i = cursor;
            synchronized (Vector.this) {
                checkForComodification();
                Vector.this.add(i, e);
                expectedModCount = modCount;
            }
            // æ’å…¥å…ƒç´ ä¹‹åï¼Œä¸‹ä¸€ä¸ªå…ƒç´ çš„ä¸‹æ ‡ç›¸å½“åŠ 1ï¼Œå› ä¸ºå®ƒä»¬ç›¸å½“äºåç§»äº†
            cursor = i + 1;
            lastRet = -1;
        }
    }
```


## 6.3 VectorSpliterator
ç›´æ¥çœ‹æºç ï¼Œè¿™æ˜¯ä¸€ä¸ªç”¨æ¥é€‚åº”å¤šçº¿ç¨‹å¹¶è¡Œè¿­ä»£çš„è¿­ä»£å™¨ï¼Œå¯ä»¥å°†é›†åˆåˆ†æˆå¤šç«¯ï¼Œè¿›è¡Œå¤„ç†ï¼Œæ¯ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸€æ®µï¼Œé‚£ä¹ˆå°±ä¸ä¼šç›¸äº’å¹²æ‰°ï¼Œå®ƒå¯ä»¥åšåˆ°çº¿ç¨‹å®‰å…¨ã€‚

å¯¹æ ‡`ArrayListSpliterator`,é‡Œé¢çš„å®ç°åŸºæœ¬ä¸€æ ·ã€‚
```java
    static final class VectorSpliterator<E> implements Spliterator<E> {
        private final Vector<E> list;
        private Object[] array;
        // å½“å‰ä½ç½®
        private int index;
        // ç»“æŸä½ç½®,-1è¡¨ç¤ºæœ€åä¸€ä¸ªå…ƒç´ 
        private int fence; // -1 until used; then one past last index
        private int expectedModCount; // initialized when fence set

        /** Create new spliterator covering the given  range */
        VectorSpliterator(Vector<E> list, Object[] array, int origin, int fence,
                          int expectedModCount) {
            this.list = list;
            this.array = array;
            this.index = origin;
            this.fence = fence;
            this.expectedModCount = expectedModCount;
        }

        private int getFence() { // initialize on first use
            int hi;
            if ((hi = fence) < 0) {
                synchronized(list) {
                    array = list.elementData;
                    expectedModCount = list.modCount;
                    hi = fence = list.elementCount;
                }
            }
            return hi;
        }
        // åˆ†å‰²ï¼Œæ¯è°ƒç”¨ä¸€æ¬¡ï¼Œå°†åŸæ¥çš„è¿­ä»£å™¨ç­‰åˆ†ä¸ºä¸¤ä»½ï¼Œå¹¶è¿”å›ç´¢å¼•é å‰çš„é‚£ä¸€ä¸ªå­è¿­ä»£å™¨ã€‚
        public Spliterator<E> trySplit() {
            int hi = getFence(), lo = index, mid = (lo + hi) >>> 1;
            return (lo >= mid) ? null :
                new VectorSpliterator<E>(list, array, lo, index = mid,
                                         expectedModCount);
        }
        // è¿”å›trueæ—¶ï¼Œè¡¨ç¤ºå¯èƒ½è¿˜æœ‰å…ƒç´ æœªå¤„ç†
        // è¿”å›falsaæ—¶ï¼Œæ²¡æœ‰å‰©ä½™å…ƒç´ å¤„ç†äº†
        @SuppressWarnings("unchecked")
        public boolean tryAdvance(Consumer<? super E> action) {
            int i;
            if (action == null)
                throw new NullPointerException();
            if (getFence() > (i = index)) {
                index = i + 1;
                action.accept((E)array[i]);
                if (list.modCount != expectedModCount)
                    throw new ConcurrentModificationException();
                return true;
            }
            return false;
        }
        // éå†å¤„ç†å‰©ä¸‹çš„å…ƒç´ 
        @SuppressWarnings("unchecked")
        public void forEachRemaining(Consumer<? super E> action) {
            int i, hi; // hoist accesses and checks from loop
            Vector<E> lst; Object[] a;
            if (action == null)
                throw new NullPointerException();
            if ((lst = list) != null) {
                if ((hi = fence) < 0) {
                    synchronized(lst) {
                        expectedModCount = lst.modCount;
                        a = array = lst.elementData;
                        hi = fence = lst.elementCount;
                    }
                }
                else
                    a = array;
                if (a != null && (i = index) >= 0 && (index = hi) <= a.length) {
                    while (i < hi)
                        action.accept((E) a[i++]);
                    if (lst.modCount == expectedModCount)
                        return;
                }
            }
            throw new ConcurrentModificationException();
        }
        // ä¼°ç®—å¤§å°
        public long estimateSize() {
            return (long) (getFence() - index);
        }
        // è¿”å›ç‰¹å¾å€¼
        public int characteristics() {
            return Spliterator.ORDERED | Spliterator.SIZED | Spliterator.SUBSIZED;
        }
    }
```

å‡ ä¸ªè¿­ä»£å™¨ï¼Œå„æœ‰å„è‡ªçš„åŠŸèƒ½ï¼Œæˆ‘ä»¬æŒ‰éœ€ä½¿ç”¨å³å¯ğŸŒğŸŒğŸŒ


# 7. å°ç»“ä¸€ä¸‹
`Vector`çš„æ€è·¯å’Œ`ArrayList`åŸºæœ¬æ˜¯ç›¸åŒçš„ï¼Œåº•å±‚æ˜¯æ•°ç»„ä¿å­˜å…ƒç´ ï¼Œ`Vector` é»˜è®¤çš„å®¹é‡æ˜¯10ï¼Œæœ‰ä¸€ä¸ªå¢é‡ç³»æ•°ï¼Œå¦‚æœæŒ‡å®šï¼Œé‚£ä¹ˆæ¯æ¬¡éƒ½ä¼šå¢åŠ ä¸€ä¸ªç³»æ•°çš„å¤§å°ï¼Œå¦åˆ™å°±æ‰©å¤§ä¸€å€ã€‚

æ‰©å®¹çš„æ—¶å€™ï¼Œå…¶å®å°±æ˜¯æ•°ç»„çš„å¤åˆ¶ï¼Œå…¶å®è¿˜æ˜¯æ¯”è¾ƒè€—æ—¶é—´çš„ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ä½¿ç”¨çš„æ—¶å€™åº”è¯¥å°½é‡é¿å…æ¯”è¾ƒæ¶ˆè€—æ—¶é—´çš„æ‰©å®¹æ“ä½œã€‚

å’ŒArrayListæœ€å¤§çš„ä¸åŒï¼Œæ˜¯å®ƒæ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œå‡ ä¹æ¯ä¸€ä¸ªæ–¹æ³•éƒ½åŠ ä¸Šäº†`Synchronize`å…³é”®å­—ï¼Œæ‰€ä»¥å®ƒçš„æ•ˆç‡ç›¸å¯¹ä¹Ÿæ¯”è¾ƒä½ä¸€ç‚¹ã€‚
ArrayListå¦‚æœéœ€è¦çº¿ç¨‹å®‰å…¨ï¼Œå¯ä»¥ä½¿ç”¨`List list = Collections.synchronizedList(new ArrayList(...));`è¿™ä¸ªæ–¹æ³•ã€‚

**ã€ä½œè€…ç®€ä»‹ã€‘**ï¼š
ç§¦æ€€ï¼Œå…¬ä¼—å·ã€**ç§¦æ€€æ‚è´§åº—**ã€‘ä½œè€…ï¼ŒæŠ€æœ¯ä¹‹è·¯ä¸åœ¨ä¸€æ—¶ï¼Œå±±é«˜æ°´é•¿ï¼Œçºµä½¿ç¼“æ…¢ï¼Œé©°è€Œä¸æ¯ã€‚è¿™ä¸ªä¸–ç•Œå¸Œæœ›ä¸€åˆ‡éƒ½å¾ˆå¿«ï¼Œæ›´å¿«ï¼Œä½†æ˜¯æˆ‘å¸Œæœ›è‡ªå·±èƒ½èµ°å¥½æ¯ä¸€æ­¥ï¼Œå†™å¥½æ¯ä¸€ç¯‡æ–‡ç« ï¼ŒæœŸå¾…å’Œä½ ä»¬ä¸€èµ·äº¤æµã€‚

æ­¤æ–‡ç« ä»…ä»£è¡¨è‡ªå·±ï¼ˆæœ¬èœé¸Ÿï¼‰å­¦ä¹ ç§¯ç´¯è®°å½•ï¼Œæˆ–è€…å­¦ä¹ ç¬”è®°ï¼Œå¦‚æœ‰ä¾µæƒï¼Œè¯·è”ç³»ä½œè€…æ ¸å®åˆ é™¤ã€‚äººæ— å®Œäººï¼Œæ–‡ç« ä¹Ÿä¸€æ ·ï¼Œæ–‡ç¬”ç¨šå«©ï¼Œåœ¨ä¸‹ä¸æ‰ï¼Œå‹¿å–·ï¼Œå¦‚æœæœ‰é”™è¯¯ä¹‹å¤„ï¼Œè¿˜æœ›æŒ‡å‡ºï¼Œæ„Ÿæ¿€ä¸å°½~ 


![](https://markdownpicture.oss-cn-qingdao.aliyuncs.com/blog/20201012000828.png)